**开闭原则(Open-Closed Principle, OCP)**：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。

### 1. 其实人人都懂开闭
开闭原则是SOLID原则的总则，“开闭”也常常被作为软件设计所追求的目标。

于笔者而言，开闭原则更像是一个口号。**一个软件实体应当对扩展开放，对修改关闭**，这句话就和老师常说的**好好学习天天向上**一样，只觉得老师讲的这句话近乎真理，无法反驳，但又完全吸取不到任何营养。

没有人愿意在新增需求时去修改历史代码，尤其是“别人的代码”，除了不得已而为之，即使是刚毕业的新人也懂得这个道理。

这里有个很常见的例子可以证明程序员对开闭原则的天生理解有多深刻：

// TODO 这里可以搞成一张compare对比的图片

```
// 代码片段2.1.1
public static byte[] getBytesByCaller(CallEvent event) {
    String caller = event.getCaller();
    byte[] body = caller.getBytes();
    int size = body.length;
    int totalSize = 12 + size;
    byte[] result = new byte[totalSize];

    result[0] = 0x01;
    result[1] = 0x00;
    result[2] = 0x06;
    // some code ...
    result[6] = (byte)(size & 0x00ff);
    result[7] = (byte)((size >> 8) & 0x00ff);
    // some code
    int type = event.getCallType();
    result[10] = (byte)(type & 0x00ff);
    result[11] = (byte)((type >> 8) & 0x00ff);
    for (int i = 0, j = 12; i < size; i++, j++) {
        result[j] = body[i];
    }
    return result;
}
```
```
// 代码片段2.1.2
public static byte[] getBytesBySpeaker(CallEvent event) {
    String speaker = event.getSpeaker();
    byte[] body = speaker.getBytes();
    int size = body.length;
    int totalSize = 12 + size;
    byte[] result = new byte[totalSize];

    result[0] = 0x01;
    result[1] = 0x00;
    result[2] = 0x06;
    // some code ...
    result[6] = (byte)(size & 0x00ff);
    result[7] = (byte)((size >> 8) & 0x00ff);
    // some code
    result[10] = 0x00;
    result[11] = 0x00;
    for (int i = 0, j = 12; i < size; i++, j++) {
        result[j] = body[i];
    }
    return result;
}
```

这是真实项目中的两个函数，这两个函数非常相似，仅有两处区别：
- body的获取不同,一个是caller，一个是speaker；
- result的10和11号byte一个根据event的type位移得出，一个写死。

这种情况在实际项目中应该非常普遍，都是先有一段已存在的代码，然后有了新的需求，于是ctrl+c把这个函数拷贝出去再改改，最后就出现了很多相似但又不完全一样的雷同代码。

这其实很能体现我们程序员对开闭原则的理解。开闭原则强调在不修改既有代码的情况，尽量通过新增类的方式扩展功能；与上面拷贝修改的思路如出一辙：拷贝代码并没有修改原来的代码块，而是通过增加一个新的函数增强了功能。

如果笔者说这些程序员之所以复制粘贴，正是因为他们对开闭原则有着深刻的理解，大部分人应该不会同意。重复代码一直是万恶之源，这种行为在很多公司的代码规范中都有明令禁止。尤其是有代码洁癖的同学，对这种行为更是深恶痛绝、嗤之以鼻；他们很难容忍这种行为，甚至会想方设法重构这个函数，让它可以同时兼容新功能和老功能，做到很好的复用。

我们如果理解了软件设计的本质，其实可以客观的分析这个问题：如果方式A比方式B能以更少的工作量完成相同的功能，那么不管方式A多么丑陋，它都是优于方式B的。所以我们只需要分析拷贝修改和重构复用两种方式的工作量消耗即可。

有经验的程序员都清楚，**拷贝修改工作量更小**：在别人的代码基础上进行修改增加功能，远比我们拷贝一个函数略改一下要困难得多。前者需要考虑对既有功能的兼容和影响，而后者代码虽多，但大都是拷贝，新写的有效代码行其实很少；而且测试时只需要关注自己新的改动点即可，总体工作量往往会更小。

大量的实践证明也是如此：“**项目时间太紧了，先抄过来改一改，后面再重构**”——这种临时决策随处可见，在进度优先的项目决策中，垃圾代码充斥着每个角落。很显然，如果不是拷贝修改更为简单，它就不会成为我们在项目进度紧张时的**第一选择**。

> **后面再重构**，是程序员或架构师常用的“缓兵之计”，类似于渣男给小三的离婚承诺，几乎不可能兑现。

但别忘了，我们衡量设计好坏的时候，强调的是**整个生命周期内**花费的总工作量，拷贝修改往往只是短期内工作量更小。

假定代码片段2.1.1和代码片段2.1.2后面都不会再有任何修改或扩展，那么我个人认为，还是不要重构的好，保持当前这种丑陋的重复代码性价比会更高；有代码洁癖和强迫症的人可能会反对我的结论，他们会想尽一切办法消除这些丑陋的代码，但事实如此，软件设计追求的从来都不是美观，而是在投入和产出之间寻找平衡。一坨“屎山”如果不再有新需求，并没有多大影响，只要我们不去碰它，它就不会熏到谁。

但实际情况却很难如愿，“世界上唯一不变的是变化本身”，尤其在软件领域，我们大多时候都无法保证一段烂代码永远不会去碰它，而一旦修改次数变多，拷贝修改的性价比将逐渐降低，直到你不得不去重构它。

上面真实项目中的例子也是如此，类似代码片段2.1.1的函数后续又加了3个（一共5个），差别都很小，而且中间的逻辑还经历过至少两次修改：这意味着，每次逻辑变动，都要修改5个函数。

> 试想一下，如果拷贝的不是五个函数，而是五个模块，后期将会是多么灾难性的后果。我们常常这么干，然后直到有一天受不了了，开始重构，做代码归一，甚至推翻重来。可是当新的项目来临的时候，我们又会好了伤疤忘了痛，仍然又拷贝了一份代码出去。历史总是在不断重演，软件行业总是一遍又一遍的重复着这种事情。

尽管我们说拷贝修改是一种制造重复代码的不良行为，但不得不说其思路还是和开闭原则保持一致的，那就是：新增需求的时候尽量不要动历史代码。无论是拷贝粘贴的普通程序员还是有代码洁癖的优秀程序员，这是大家都认可这个结论，我们都希望用更少的代价完成相同的功能，只是两者实现的方式存在差异：前者着眼于当下，后者兼顾未来。

这就好比普通工人和优秀工人分别制作了一个水龙头，交给客户使用。有一天，客户说，想把当前这种需要人工扭动阀门式的水龙头换成自动感应出水的水龙头。大家都知道这项工作非常复杂，这需要搞清楚阀门水龙头里面的结构细节，哪些零件要换，哪些不动等等，最终普通工人和优秀工人都觉得应该要把旧的阀门式水龙头直接扔掉，重新做一个新的感应式水龙头更好。但是普通工人，则是把以前的水管和水龙头全扔了，换了一套全新的水管和水龙头；而优秀的工人会发现，水龙头未来还可能换，水管也可能会破裂需要单独修或者换，于是将水管和水龙头切割开做成了一个接口，只换了一个水龙头。

两者都知道开闭的重要性——做一个新的要比修改原有的水龙头要容易一些，但处理方式和最终的结果却有天壤之别。

所以，“开闭”绝不是指不允许修改任何历史代码，也不是指可以报复性增加大量代码随意扩展，这是对开闭的极端理解；正确的做法是我们需要根据实际业务和未来最可能的发展方向来决定：我们该**开**哪些代码，**闭**哪些代码。

### 2. 对修改封闭，对变化开放

这是代码片段2.1.1和代码片段2.1.2重构后的样子：
```
// 代码片段2.1.3
public static byte[] getBytesByCaller(CallEvent event) {
    return getBytes(event.getCaller(), event.getCallType());
}

public static byte[] getBytesBySpeaker(CallEvent event) {
    return getBytes(event.getSpeaker(), 0);
}

private static byte[] getBytes(String bodyStr, int type) {
    byte[] body = bodyStr.getBytes();
    int size = body.length;
    int totalSize = 12 + size;
    byte[] result = new byte[totalSize];

    result[0] = 0x01;
    result[1] = 0x00;
    result[2] = 0x06;
    // some code ...
    result[6] = (byte)(size & 0x00ff);
    result[7] = (byte)((size >> 8) & 0x00ff);
    // some code
    result[10] = (byte)(type & 0x00ff);
    result[11] = (byte)((type >> 8) & 0x00ff);
    for (int i = 0, j = 12; i < size; i++, j++) {
        result[j] = body[i];
    }
    return result;
}
```
我们发现，这样修改后，再增加功能依然也是拷贝修改，只不过拷贝的只有一行。比如：
```
public static byte[] getBytesByResponse(ResponseEvent event) {
    return getBytes(event.getCallee(), event.getType());
}
```
而且一旦getBytes函数逻辑发生变更，也只需要修改一处即可。

所以开闭原则的本质不在于开闭，而是**开什么，开多少和闭什么，闭多少**的问题。
开：指的是在需求发生变更时，尽量做到可以通过新增类，方法的形式达成目的。
闭：指的是在需求发生变更时，尽量不要影响到已有的历史代码代码修改。

要做好开闭：则需要准确识别出业务当前以及未来的变化点，将软件拆分成多个内聚的组成部分，再通过解耦对各个组成部分进行隔离，让其中相对稳定的模块可以共用或稳定复用，让相对易变的部分容易扩展，而且尽量互不影响。

做好了开闭，即做好了复用。



### 3. 总结

开闭是设计原则的总则；

开闭的优点众所周知，但实现开闭时往往会有人陷入短期利益中，给后期带来巨大额外开销；

开闭本身不难理解，难的是如何正确实现开闭，即**开什么，开多少和闭什么，闭多少**的问题；

开闭自己只讲了什么是好的设计，至于如何实现，都交给了其他设计原则。