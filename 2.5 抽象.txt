抽象是软件设计的灵魂。
我们在讨论软件设计的时候，总感觉“抽象”无处不在，甚至在每个设计原则和模式中都能找到“抽象”的影子，但很多时候我们又很难讲清楚“抽象”到底是什么。因为“抽象”这个概念本身就很抽象。
如果不能很好的理解抽象，那么一个人对设计原则和模式的理解很可能仅仅只停留于表面。
抽象如此重要，所以我将它放在了所有设计原则和设计模式的章节之前。

### 1. 什么是抽象

关于“抽象”我没有找到特别好的解释（可能存在，但我确实没有找到），于是我尝试自己定义了一个：
抽象：根据业务关注点，对一类事物剥离个性，归纳共性的过程。

抽象，有时候是动词，有时候是名词，有时还可以是形容词。
作为动词时，代表抽象的过程；比如我们说把一个具体业务抽象一下。
作为名词时，代表抽象这个动作的结果；比如这个接口是对火车的一个抽象。
而作为形容词时，讲的其实是抽象的程度；比如这个类设计的太抽象了，说的是抽象的高度。
一般根据上下文，我们都能很轻易的辨别其想表达的意思。


### 2. 抽象的关注点

如果我们要完整的描述一个具体的人，应该是一件不可能做到的事情：
一个具体的人的物理结构本身已经复杂无比：身体分为多个部位；每个部位又由无数个细胞组成；细胞又可以分成原子；原子又分为粒子；粒子又分为夸克；如果人类的认知范围继续扩大，应该还可以再分下去。而这些组成部分，对一个具体的人来说，都是独一无二的。除了物理组成，还有人的各种状态，社会关系，经历等等。而且所有的这些属性还在时间维度下持续变化。
即使我们可以收集到一个人的所有这些信息，也没有办法存储，地球上所有的存储介质加起来也不够。

幸运的是没有任何场景我们需要如此完整的描述一个具体的人，往往我们只需要提取出我们所关注的特性即可。比如：

对于一个物流系统来说，一个人只是包含地址，电话，姓名的组合，动作属性则是寄信收信；而对于一个婚恋网站而言，一个人则是性别，年龄，身高，职业，年收入，是否再婚的组合，动作属性则主要包含聊天，送礼等行为。
钱对于银行的印刷系统来说，有版号，编号，面额，批次，印刷日期等属性；但是对于一个电商系统而言，它连对象都不算，只是个没有感情的数值。

当我们将一个人描述为一组特定的属性和行为的组合时，这个过程便是抽象，而最终这个系统中关于人的定义，就是抽象的结果。这个定义，是对一类事物的归纳描述，这些属性或行为并非某个具体的人所独有，而是人类这个物种所共同拥有的特征。换句话说，人的抽象是在某个特定场景下所有人所共有的一些属性和行为。

// TODO 
抽象是一种看穿事务本质的能力。
现实中有一些明白人，总能一针见血的点出问题的关键点，又或者能精准的预测某件事情的未来走向。无他，原因有二：
1. 明白人有着相当的阅历；2. 明白人看到的并非事情表面，而是内在的一些底层逻辑，而这些底层逻辑本身就是一类事务的共性所在，所以可以举一反三应用在其它事情上。
同样，软件设计中的抽象也是如此。要想做好抽象，首先设计师对当前的业务场景要足够熟悉（相当于阅历）；其次设计师要对这些业务要有自己独特的理解（具备底层逻辑）；最后将这些理解转换成对应的软件模型即可。
除了最后一步需要软件领域的专业知识外，前两步与“明白人”的逻辑一样。所以，一个特定领域的架构师，除了应有的技术能力外，还应具备完备的业务理解。

// TODO
高层抽象除了业务场景外 还需要考虑一些技术细节

// TODO 
#### 关注点的定义和拆分
在上面的例子中，似乎划分属性和行为的过程特别简单，就像我们把人的身体分为头，身体和手一样；它们的划分界限过于明显，我们会很自然的把人的身体分为这几个部分，好像理所当然一般。但实际工作中，越到细节处越难以区分。
比如我们将人的头部划分了嘴巴，鼻子，耳朵等模块，现在需要实现一个呼吸功能，那么我们应该将这个功能划分在哪个模块中才合适？
有人会认为放在鼻子中，但是如果鼻子塞住了，其实我们可以用嘴巴呼吸。如果深入了解，我们会发现鼻子和嘴巴只是提供呼吸的接口而已，呼吸的具体实现应该放在肺这个模块中。

在软件实现层面，一个对象应该有多少个属性，有多少个方法；具体的一个属性、一个方法应该如何定义，定义在哪其实都并非易事，这不仅需要长时间的设计经验，也需要对业务有着深刻的理解。

> 在实际工作中，如果没有做好抽象，清晰的定义好每个模块的职责，最终会导致子系统、模块或类纠缠不清，最终多个团队会因为一个特性该由谁做而争执不休。

### 3. 抽象的层次
我们在对一个事务进行抽象时，很像是对一个概念的分解，比如上面例子中将物流系统中的人分解为地址，电话，姓名多个属性的组合。
一旦涉及到分解，就必定会有层次的概念。

比如我们在抽象人的身体结构时，会这样描述：
人的身体结构由头部，身体躯干和四肢组成；在第二层则会把四肢分为左手，右手，左腿，右腿；第三层则会把左手分为大臂，小臂，手肘和手掌；第四层手掌可以分为大拇指，食指，中指，无名指，小指和掌心。就像金字塔一样一层一层划分下去。
但我们决对不会说人的身体就是一个身体，这种描述没有意义；我们也不会说人的身体是由多少根头发，多少根眉毛，两个黑眼珠，两个眼眶，一个上嘴唇，一个下嘴唇，多少颗牙齿等等组成的，这样完全没有层次的定义也会过于复杂。

一个相对比较复杂的事务都会涉及到逐层分解，这种金字塔式的递归划分方式主宰着整个人类社会：任何一个大的国家或公司的组成，数字（个十百千万），时间（秒分时天月年）都是如此。
我们每个个体都存在能力上限，无法同时理解和处理过多相关联的事务，我们不可能让一个CEO直接管理所有的员工；而通过增加层级，可以有效减少每个个体的接触面。
当然，层级的增加也会带来一些问题。首先是资源上的浪费，层级多了一定会需要额外的管理成本，就如同一个公司当官的人太多了，干活的人自然就少了；其次效率也会降低，一些信息下达到基层每次都需要经过层层传递，兄弟部门间的信息传递也会变得复杂，而且中途还有可能出现信息丢失。

软件领域的分解也是如此：
一个大的电商系统，一定会先分为若干个子系统，比如用户管理系统，商品管理系统，支付系统，物流系统等等；每个子系统又再分为多个子模块；最终是一些高层次抽象的类，下面是一些低层次抽象的类；即使到了最细节的函数层面，依然存在层次关系。

层次是抽象中非常重要的一概念。一个系统越大，层次也会越多；同时，过多的层次也会导致接口模块臃肿，调用链过长等问题。

在实际工作中我们应尽量避免跨层调用：一个对象应该只与自己的直接上级、直接下级或兄弟层级（具有相同上级的同一层抽象）产生关系。

比如每本书都包含目录，前言，书本的正文和结语四个部分，其中正文还包含若干章节。我们现在使用伪代码模拟撰写本课程的过程：
```
void 写书() {
	撰写目录
	撰写前言
	撰写第一章节
	撰写第二章节
	撰写第三章节
	撰写结语
}
```

尽管每一个章节的字数要比目录，前言和结语要多很多，但这仍然不能决定他们的层次高低关系。就像我们不能根据部门大小和人数来决定两个部门经理的行政地位一样。很明显，“撰写正文”才是写书的直接下级，将撰写第一章节、第二章节和第三章节放在写书这个函数中，其实相当于让“写书”和自己的下级（正文）的下级产生了关系。

所以代码修改成如下才是合理的：
```
void 写书() {
	撰写目录
	撰写前言
	撰写正文
	撰写结语
}

void 撰写正文() {
	撰写第一章
	撰写第二章
	撰写第三章
}
```

这样写的好处在哪里？试想一下，当我想再写一本新书的时候，而新书比原来多了一个章节。前者我们需要修改“写书”这个函数，而后者只需要修改撰写正文这个函数，从修改代码行上两者似乎差别不大；但从复用性上看，前者无法复用，而后者复用了写书这个函数，一共7行代码，复用了4行；而且由于将低层抽象剥离出去，“写书”这个函数也会格外稳定（每本书的整体结构基本不会发生变化，都是包含目录，前言，正文和结语四个部分）。

在一个大的系统中，抽象层次的划分，以及管理好各个层次间的关系都非常重要，这会直接决定一个模块乃至整改系统的可复用性和稳定性。

> 在一个系统中，层次越高的抽象就应该越稳定，它所带来的影响也巨大。高层次的抽象定义是架构师需要誓死捍卫的东西，不到万不得已，我们不应去破坏这些高层抽象。
比如电商系统在最顶层常常分为支付、订单和物流等子系统，一旦这些顶层子系统都出现了划分错误需要修改，所需要付出的代价将会非常恐怖。


### 4. 抽象的高度

抽象的高度和抽象的层次是两个完全不同的概念，但是又非常容易混淆，甚至很多时候我们都没有加以区分。如果有人说一个抽象有点高，一般表达的都是高度太高，有时候需要结合上下文，才能搞清楚他说的是层次还是高度。在本课程中，后续提到高低，或者高层抽象低层抽象都指的是抽象的高度。

高度更高的抽象，是剥离了更多的个性的表现，这也使得更高的抽象往往能容纳更多的事物；
比如张三，我们可以将他抽象成一个人：会说话，会走路，有身份证号，年龄属性；人这个概念剥离了张三的个性；
我们还可以将张三抽象成动物：会发出声音，会移动，有年龄属性；动物不仅剥离了张三的个性，还剥离了人的一些特殊属性；
甚至，我们还可以将张三抽象成生物：可能就只剩下活着还是死了这一个状态属性了；生物则进一步把动物的一些个性行为也剥离了；
（层次越高的抽象对稳定性要求越高，所以往往层次越高的抽象高度一般也会越高，其实抽象的高度和层次是两个完全独立的概念，并没有直接关系）


> 抽象的层次，描述的是组合关系的高低，比如军队和士兵，公司和员工；抽象的高低，描述的是继承关系的高低，比如动物和人，人和张三；

正因为剥离了更多的个性，所以更高的抽象包容性会更好。


比如一个函数使用“人”这个抽象，那么它可以提供给张三，李四各种具体的人使用，但是没法提供给其他动物使用；但如果它使用的是“动物”这个抽象，那么这个函数不仅可以给张三，李四使用，还可以供各种阿猫阿狗使用；

```
// 可以传递张三、李四等人的具体实例对象
public void method(Person person) {
    // some code
	...
	
	person.walk();
	
	// some coe
	...
}

// 抽象更高，可以将阿猫阿狗作为参数传入
public void method(Animal animal) {
    // some code
	...
	
	animal.walk();
	
	// some coe
	...
}
```

如果抽象得更高，会剥离更多的个性，从而对依赖这个更高抽象的函数或类提出更高的兼容性，很多时候甚至无法完成。比如上面的例子中，如果再将动物拔高到生物，便无法实现了，毕竟植物没有走路这个方法。
```
// 生物不一定都有walk这个方法，导致函数无法实现
public void method(Biological biological) {
    // some code
	...
	
	// ？？？树怎么走？
	biological.walk();
	
	// some coe
	...
}
```

所以在相应的抽象高度，我们只能实现相对应的功能；而抽象所剥离的那些个性，最终会下沉到一些具体的业务模块或细节代码中。


这里有一个比较实际的业务场景可以用来说明不同高度的抽象所造成的影响。有一个卖桃子的老板希望我们帮他做一个软件，每天统计一下自己卖了多少钱的桃子。

1. 抽象过低（完全不做抽象）：

   直接按照老板的需求，迅速的开发出一个软件，只需要每个顾客来买桃子，填上对应的斤数就可以了，系统后台自动乘以单价然后累加金额就好了。 

   这个软件对桃子老板来说确实好用，拿来即用。但是坏处也特别明显，桃子单价变了，软件就得升级；卖其他水果或多种水果的老板也没法用，更不用说小卖部和商超。

2. 适当抽象：
   从老板的业务来看，主要有商品（包含名称，单价等属性），还有交易（卖的什么商品，卖了多少，总金额）两个实体，这样抽象后做出来的软件，我们发现至少一些小商贩都可以用了，但是前提是他们得预先录入一些商品和价格信息。这时桃子老板还能接受，毕竟就录入桃子就好了。

3. 抽象过高：
   我们想一劳永逸做一款无所不能的软件，这样，我们不仅可以给桃子老板用，还可以卖给加油站老板，出租车公司，政府单位。于是我们经过很久的思考，觉得所有这些业务的共性都无外乎是：数据+流程（操作）；于是我们开发了一个支撑各种数据定义，以及各种循环，判断，分支等流程语法的软件。最后我们发现做出来的东西就是和JDK一样的编程语言软件，产品文档则是一本java开发手册，最终桃子老板就只能骂街了。

我们可以通过这个例子看出一些规律：
- 抽象过低的前期工作量最小，而且对于客户来说使用最方便，但一旦业务场景扩张或者需求开始膨胀，过低抽象的短板开始体现，最终可能需要给每个客户定制一个软件。
- 适当抽象的前期工作量略大，在客户界面需要进行一些个性化配置；但是由于抽象带来的可扩展性，在业务场景扩张和需求变更时，受冲击的影响较小，最终的总工作量会远小于不做抽象。
- 抽象太高的前期工作量最大，我们不仅要维持高层抽象的通用性，还要遗留一堆具体的业务逻辑在低层抽象中实现；反之其带来的好处是极为灵活，如果业务场景和需求并没有按照预期进行扩张，会造成前期的工作量浪费，甚至这种灵活可能会毫无意义，有时候**什么都能做等于什么都不能做**。


总的来说：
- **抽象的层次越高 -> 相对趋向于灵活、稳定、易复用但难以应用**
- **抽象的层次越低 -> 相对趋向于僵硬、异变、难复用但容易应用**

抽象的高度不宜过高，也不宜过低。
在高度相差较大的抽象层中间我们往往会增加一些中间抽象和模块，比如在生物和张三之间，保留动物，人这两层抽象；

而无论怎样，软件设计总是会陷入这种两难的境地：
- 向左是不做抽象————设计薄弱，丢失扩展性，后期业务扩展需要投入巨大人力；
- 向右是抽象过高————过度设计，前期投入多，后期如果未有效复用则形成浪费；

所以又回到了耍赖的阶段：最好的抽象是“刚刚好”。下面这段话来自于Uncle Bob，比较能表达什么是“刚刚好”：


**根本不存在充分分析这种东西，无论花多少时间试图去找出完美的软件结构，客户总是会引入一个变化破坏这个结构。这种情况是无法避免的，不存在完美的结构，只存在试图去平衡当前的代价和收益的结构。随着时间的过去，这些结构肯定会随着需求的改变而改变，管理这种变化的诀窍是尽可能的保持系统的简单灵活。**
                                      ——摘自bob大叔《敏捷软件开发 原则、模式与实践》
									  
> 抽象的高度是一个相对概念，这里会存在一个误区，很多人认为只有接口和抽象来才是抽象，其实不然，连最基本的int类型相对于整数1,2,3来说也是抽象。

### 5. 总结

抽象是所有设计原则的基础，而设计原则又是所有设计模式的基础。

任何两个事务都可以抽象到同一个概念上来：java的Object类就是所有对象的顶级抽象，而由于java中的函数并非对象，使用了类似于Callable, Runnable等接口作为函数的顶级抽象；