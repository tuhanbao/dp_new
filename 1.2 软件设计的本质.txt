在本小节，我们主要讨论一下软件设计如何减少工作量。

这里有一个生活中的例子：现在有一个快递小哥，他要把包裹1号从A地运送到B地，包裹2号从C地运送到D地。正常情况下他会依次运送包裹1和包裹2，如果想要更快一些，有什么办法？

我们的第一反应是给他提升效率，可以给小哥搞辆电动车，提升他的移动效率。如果还想更快，可以看下能不能搞一辆更快的车。

当然，我们也还可以换一种思路：看下AB和CD这两条路径是否有重合的地方，比如 这两条路径有一段X->Y的路线是重叠的，即A->X->Y->B，C->X->Y->D，那么我们可以让快递小哥先将包裹1号从A运送到X处，再回去将包裹2号从C运送到X处，然后将两个包裹一起从X运到Y处，再从Y处分别运往B和D，多多少少都能省点时间。

我们可以再多想几个例子，其实会发现，大部分事情如果要降本增效，大致都只有这两类方法：
1. 技术革新（发明一辆车：提高效率）
2. 复用（复用了X->Y的运送：减少工作量）

其中技术革新可以极大的提高工作效率，甚至让原有的效率提升N个数量级，或者直接让工作量无限接近于0。比如未来如果普及了无人机送货直接到家，外卖小哥可能直接失业。

技术革新的效果非常明显，但门槛也高，从无到有发明一辆电动车或汽车所需要经历的坎坷和波折可想而知。

相比技术革新，“复用”实施起来要容易得多，但所起的效果并不总是那么明显，而且还和具体的场景强相关。比如AB，CD两条路径没有重合的路线，就会完全没有作用；而如果AB，CD就是同一条路线，工作量则直接减半。

对于软件开发这项具体的工作而言，也同样如此。

我们可以发明一些更高级的语言，更好的IDE工具，针对具体的业务开发一个高效的低代码或无代码平台，甚至还可以发明AI，让机器人来代替人工写代码。这些都可以极大的减少工作量或者提高工作效率。

当然，我们还可以通过一些朴实无华的“复用”手段减少工作量，这并非多么高明的技巧，只是软件中的重复并不会像路线重叠那样显而易见，有些时候需要我们自己去创造和发现，而这项工作正是我们所说的“软件设计”。

和生活中“复用”的例子一样，软件设计也有以下特点：
1. 软件设计所起的效果和具体的场景有关，存在天然上限：如果我们将所有可复用的地方都复用了，软件设计的作用就发挥到了极限；
2. 软件设计没有技术门槛。A国可以通过封锁芯片，EDA软件来卡脖子，但软件设计永远不会成为技术瓶颈，只要你愿意，就可以将它使用在方方面面；
3. 软件设计不属于技术革新，只是一种普遍实践经验，未来也不太可能会有理论上的突破；
> 自从1995年GoF的《设计模式》出版以及SOLID原则被提出后，软件设计的理论基本没有革新，时而有一两本新书，也都是基于设计原则和模式的二次理解（包括本书也是）。我们也可以说软件设计理论从来就没有改变过，它一直在那，只是刚好1995年出了一本比较经典的书籍，我相信未来很长时间内也不会有新的软件设计理论出现，最多多出一些新的理解。

我们必须承认，软件设计存在它的局限：
- 在低效的语言上将设计模式运用的天花乱坠，永远也比不上发明一种更高效的语言或新技术；正如用人的两条腿跑路，无论你如何设计路线，永远也比不上电动车无脑送货；
- 但是，无论多么高级的语言和多么新的技术，都可以在其基础上通过恰当的运用设计技巧再进一步提高收益。正如无论多么快的交通工具，也都可以通过规划和设计路线让时间再缩短一些。

**软件设计没有未来，但永不过时。**

各种编程语言、三方框架和工具都是一些“术”，而设计理论更偏向于“道”。我们学习了一门编程语言，三方件或工具，总有一天会被淘汰；但是深刻理解了设计原则和模式，将一辈子受用。这也是“软件设计”如此重要的原因。

### 1. 复用

我们对软件设计中“复用”的理解有时会偏狭隘，认为一段代码重复使用才叫“复用”，其实不然。

实际项目中我们读代码的时间会远远超过写代码的时间，所以要有效的减少工作量，除了“写”复用，更要“读”复用。

总的来说，“复用”包含以下两种方式：
1. 写复用：共用一段代码，避免重复造轮子，比如我们常见的公共代码和工具类，这也是**复用**最基本最简单的方式。
2. 读复用：让程序员避免重复理解之前的业务逻辑和历史代码；历史代码一定是被某位程序员理解过一遍业务逻辑而后写出来的，如果换了程序员，或者时间隔了很久，突然要修改它，那么必定导致这里的业务逻辑和代码要重新梳理，可能正因为一次次的修改，相同的代码要重复的一遍一遍被读和被理解。

实现读复用相比于实现写复用要更为困难一些。

为了达到“读复用”，我们一般会使用一些设计原则或模式，来达到“隔离变化”的效果，让代码在修改或增加需求的时候尽可能少的影响历史代码。为了实现这种“隔离变化”，这往往都需要我们增加一些额外的抽象接口或中间类，从而导致代码更难以理解，以及更多的代码量投入。所以如果“读复用”的实现方式使用不当，还会出现负面效果，这也是我们常说的“过度设计”。比如架构师错误的预估了业务的变化方向，让预留的有些点“可扩展”但实际并不需要扩展，造成工作量的浪费。就好比我们要做一双筷子，我们预估它会被使用很多次，所以我们把这双筷子做得很结实；但是后来的实际情况是，这双筷子只被使用了一次，这明显造成了浪费，还不如一开始就做一双一次性筷子。

我们必须清楚“读复用”是需要付出一定代价的。所以如果严格地说，软件设计的本质是追求“有效复用”，

> 尤其对于一些有代码洁癖的人，“过度设计”会经常发生，他们在编写代码的时候习惯会对未来预留一些扩展，但一旦与预期不符，就出现了“浪费”。我个人认为，轻微的“过度设计”是可以接受的，只有不做设计才永远不会过度设计！但如果总是频繁出现“过度设计”，那么我们应该引起重视，看下是否是自己的设计理念过于偏激，或者对业务的理解还不够透彻。


相比于写复用，读复用的效果也更为明显。因为很多时候：**改是质的问题，改多少是量的问题**。

在实际项目中，“读复用”很差的代码常见的表现是：一个很小的业务改动，会引起大范围的改动甚至改动非常困难。主要原因是各模块/类纠缠不清，耦合严重（代码僵硬），最终即使修改的总代码行也不多，但由于影响到多个模块，我们需要阅读大量的历史代码，然后精准的找到这些代码的修改之处，修改完之后还需要重新编译、打包、测试、部署等等，导致最终工作量非常庞大。

而且，可以“读复用”的模块和代码因为其良好的高内聚低耦合性，一般也能被“写复用”，这些因素最终导致“读复用”在软件设计中变得格外重要。


### 2. 复用的步骤

活字印刷术其实能很好的说明软件复用。

最开始出版书籍都是靠手抄，后来科技进步，出现了雕版印刷术，可以用印刷代替手抄，效率有了明显提升。但是这样会存在一些问题，就是每出一本新书的时候，都要重复刻板子，工作量非常大；一旦出现了错别字，也需要重刻。于是后面又出现了活字印刷术，活字印刷术相比于印刷术其实并没有技术上的革新，它只是一个简单的复用技巧，把所有常见的字都刻几份，通过组装字块到一块板子里进行印刷，这样每次出新书就可以复用这些字块，不用每次都重新刻板。另外，由于字块过于分散每次拼板子也有点费时，于是我们还会把一些常用的词语合起来做成一个大的字块，这样找字块和拼字块的效率会略高一些。

印刷术中的“写复用”相当于共用字块。比如很多书籍都包含同一个字，为了共用，我们不得不把这个字拆出来做成单独的字块。
“读复用”则相当于希望修改某个字时不会影响其他字。比如有一个字刻的不好看，想改一下，如果是雕版印刷术，整块板子都得重刻；而活字印刷术，只需要修改一个单独的字块。

无论是“写复用”还是“读复用”，第一步都必须先将这些字块拆到合适的粒度。软件上的复用亦是如此。

写复用：一个相对较大的函数，如果其中有可以给别处共用的代码，则需要将其进行拆分；

读复用：读复用的核心是“隔离变化”，其第一步依然是拆解，然后根据具体情况通过一些“解耦”的手段来优化两者之间的依赖关系。

在活字印刷术中，“写复用”体现为将雕版印刷术中的板子拆分成一个一个的字块，这些字块可以重复使用。“读复用”则体现为一套固定的刻字标准，比如字块的长宽高，订好了这套标准，每个字块只需要按照标准控制好自己的大小即可，至于别人如何使用字块，如何与其他字块配合，都不需要关心；这就像极了我们平时定义的一个接口，我们只需要实现好这个接口即可，至于调用方如何使用接口，其他人如何实现接口，都与自己无关。


#### 3. 软件设计的本质

所以：**软件设计的本质是有效复用**。

当我们提到软件设计的本质时，总会出现各种名词，诸如“隔离变化”、“高内聚低耦合”、“面向抽象编程”、“可扩展”、“开闭”等等；而这些词就像店老板所高呼的“客户是衣食父母”一样，当一个受虐狂客户想让我们打他一顿的时候，我们又何必将他像父母一样对待，不要忘了开店的最终目的是“赚钱”。“隔离变化”、“高内聚低耦合”、“面向抽象编程”、“可扩展”、“开闭”这些词虽然正确，但大都只是描述了如何进行“读复用”，即在变化发生时如何尽量少的影响历史代码以及少写代码；它们大都忽略了“写复用”，也忽略了很多时候我们其实根本不需要面向抽象，不需要做到可扩展和高内聚低耦合。软件设计追求的目的并不是这所谓的“优雅”，而是“有效复用”。
> 一段陈年老代码，即使丑陋不堪僵化无比，如果未来这里不会再有新的需求，只要功能没有问题，让它放在那里保持原样即可，重构这些代码只会造成人力上的浪费。

优秀的架构师，不仅要面向未来预留扩展，也要着眼当下杜绝没有必要的浪费。