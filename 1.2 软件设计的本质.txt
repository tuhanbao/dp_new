在前一章节，我们讨论了软件设计是通过减少工作量来节约成本的，而不是通过提升效率。在本章，我们主要仪器讨论软件设计是如何减少工作量的。

我们先来看一个生活中的例子：
现在有个快递小哥，他要把包裹1号从A运送到B，包裹2号从C运送到D。如果我们希望他能用最短的时间完成所有运送，会有什么办法？

我们的第一反应是给他提升效率，
给小哥搞辆车，提升他的移动效率。还有吗，还有就是看下能不能搞一辆更快的车。

其实还有一种方法：我们可以看下AB和CD这两条路径是否有重合的地方，比如 中间有一段X->Y的路线是重叠的，即A->X->Y->B，C->X->Y->D，那么我们可以让快递小哥先将包裹1号从A运送到X处，再回去将包裹2号从C运送到X处，然后将两个包裹一起从X运到Y处，再从Y处分别运往B和D，多多少少都能省点时间。

我们可以再多想几个例子，其实会发现，做任何一件事情，如果要减少成本，大致都只有这两类方法：
1. 技术革新（发明一辆车）
2. 复用（复用了X->Y的运送）

其中技术革新极大的提高了效率，有时候一个新技术的出现甚至可以出现降维打击，让原有的效率提升N个数量级，或者直接让工作量无限接近于0。比如未来如果全是无人机送货直接到家，外卖小哥可能直接失业。
技术革新的效果非常明显，但门槛也高，从无到有发明一辆电动车或汽车所需要经历的磨难可想而知。
相比技术革新，“复用”实施起来要容易得多，所起的效果也和具体的场景有关，如果AB，CD没有重合的路线，就会完全没有作用；如果AB，CD就是同一条路线，工作量直接少一半。

对于编码这项具体的工作而言，也同样如此。
我们可以发明一些更高级的语言，更好的IDE工具，针对具体的业务开发一个低代码平台，甚至发明一种脑机接口，让你的想法直接转变成代码；这些都可以极大的减少工作量或者提高工作效率。
但可以肯定的是：软件设计绝不属于技术革新。它只是通过一些朴实无华的“复用”手段减少工作量，并非多么高明的技巧，只是软件中的重复并不会像路线重叠那样显而易见，有些时候需要我们自己去创造和发现，仅此而已。

和生活中“复用”的例子一样，软件设计也有以下特点：
1. 软件设计所起的效果和具体的场景有关，存在天然上限：如果我们将所有可复用的地方都复用了，软件设计的作用就发挥到极限了。
2. 软件设计没有技术门槛。A国可以通过封锁芯片，EDA软件来卡脖子，但软件设计永远不会成为技术瓶颈，只要你愿意，可以使用在方方面面。
3. 软件设计不属于技术革新，只是一种普遍实践经验，未来也不太可能会有理论上的突破。
> 自从1995年GoF的《设计模式》出版以及SOLID原则被提出后，软件设计的理论基本没有革新过，时而有一两本新书，但都是基于设计原则和模式的二次理解（包括本书也是）。当然，我们也可以说软件设计理论从来就没有改变过，它一直在那，只是刚好1995年出了一本比较经典的书籍。我相信未来很长时间内也不会有新的软件设计理论出现，只会出现一些新的理解，换汤不会换药。

我们必须承认，软件设计存在它的局限性：
在低效的语言上将设计模式运用的天花乱坠，永远也比不上发明一种更高效的语言或新技术；正如用人的两条腿跑路，无论你如何设计路线，永远也比不上电动车无脑送货；
但是，无论多么高级的语言和多么新的技术，都可以在其基础上通过恰当的运用设计技巧再进一步提高收益。正如无论多么快的交通工具，也都可以通过规划和设计路线让时间再缩短一些。

**软件设计没有未来，但永不过时。**

各种编程语言、三方框架和工具都是一些“术”，而设计理论更偏向于“道”。
我们学习了一门编程语言，三方件或工具，总有一天会被淘汰；但是深刻理解了设计原则和模式，将一辈子受用。这也是学习软件设计如此重要的原因。


我相信讨论到这里，一定会有同学质疑上面的结论：我们可以承认好的软件设计有时确实会使用一些“复用”手段来优化我们的代码，但这并不代表软件设计就等同于“复用”。
因为软件设计还包含很多其他的东西，有时它可以给我们带来更好的“灵活性”、“可扩展性”、“可维护性”、“鲁棒性”、“稳定性”、“易修改性”等等。

当我们还没能真正看清一个事情的本质的时候，往往就会出现五花八门的定义或描述。
比如我们要定义“走”和“跑”的区别，即使我们每个人至少都有十年或数十年的实践经验，但依然很难精准的对“走”和“跑”下定义。我们可能会有下面的一些描述：
- 跑要快一些，走要慢一些；
  但是具体速度要达到多少公里每小时才能算快，却说不清楚。
- 方式不同，跑需要手臂大幅摆动；
  如果我在走路的时候大幅摆动手臂算不算跑？
- 走是平稳而轻松的向前移动，属于低强度的运动，心率较慢；跑是摆蹬结合的高强度运动
  依然无法定义，什么叫平稳轻松，强度达到什么程度才算高，心率达到多少算快？
- 跑步身体会前倾，往往是脚掌先着地；走路身体不会前倾，往往是脚跟先着地。
  那么我故意身体前倾一些，脚掌先着地慢慢往前走，就算跑步了吗？

如果我们去咨询专业的竞走运动员，他们会说：“走路不能两只脚同时悬空”。
这才是走路和跑步的本质区别！
所谓的速度快慢，身体前倾幅度，手臂摆动，运动强度，脚跟先着地还是脚掌先着地等等，所有的这些都只是这个本质下的外在表象。


所以，当我们评价一份优秀的代码时所说的：“高内聚低耦合”、“解耦”、“隔离变化”、“可维护”、“可扩展”、“灵活”、“稳定”等等，他们都只是“好代码”表露出来的外在形象。
我们从来不会看到这些名词对立的出现，比如一份可维性很强的代码不灵活，又或是一个高内聚低耦合的模块可扩展性很差。
这些词本质上就是一个东西，他们存在一个共同的“根”，也就是软件设计的本质——“复用”

“可扩展”、“可维护”、“灵活”、“高内聚低耦合”这些表象都不是我们所追求的目标，软件设计最终要达到的目的一定是全局工作量最优从而为企业或者公司带来应有的商业价值，在不引入新的技术的条件下能达到这一目标的只能是“复用”。

读者们并不需要在此和我意见达成一致，我会在后面整个课程阐述这一结论，最终我们会发现所有的设计原则、设计模式以及设计理念其实都只是在为更好的“复用”服务。

> 虽然我们很多人并不知道走路和跑步的本质区别，这并不妨碍我们生活中去辨别一个人当前是在走路还是在跑步，但并不是每个人都可以去做竞走运动的专业裁判。就如很多资深程序员，即使不能归纳出软件设计的本质，这也并不妨碍他对好的设计的理解以及对优美代码的识别。但如果我们想成为一名真正的大师，就必须穿过那五花八门的设计原则和设计模式，在背后去寻找你心中关于软件设计的“根”。你的答案可能和我不同，但对设计本质的追求这个过程本身就一定会让你受益匪浅。

### 1. 复用

我们可以先统一一下“复用”的概念。

我们很多人对“复用”的理解其实偏狭隘，会认为一段代码重复使用就叫“复用”，其实不然。有经验的程序员都知道，实际项目中我们读代码的时间会远远超过写代码的时间，所以要有效的减少工作量，除了“写”复用，更要“读”复用。
总的来说，复用包含以下两种方式：
1. 写复用：共用一段代码，避免重复造轮子，写过的就不要再写了，比如我们常见的工具类，这也是**复用**最基本最简单的一种方式。
2. 读复用：让程序员避免重复理解之前的业务逻辑和历史代码；历史代码一定是被某位程序员先理解一遍业务逻辑然后写出来的，如果换了程序员，或者时间隔了很久，突然要修改它，那么必定导致这里的业务逻辑和代码要重新梳理，可能正因为一次次的修改，相同的代码要重复的一遍一遍被读和被理解。

读复用相比于写复用要更困难一些。
为了达到“读复用”，我们一般会使用一些设计原则或模式，来达到“隔离变化”的效果，让代码在修改或增加需求的时候尽可能少的影响历史代码。为了实现这种“隔离变化”，这往往都需要我们增加一些额外的抽象接口或中间类，从而导致代码更难以理解，以及更多的代码量投入。所以如果“读复用”的实现方式使用不当，还会出现负面效果，这也是我们常说的“过度设计”。比如架构师错误的预估了业务的变化方向，让预留的有些点“可扩展”但实际并不需要扩展，造成工作量的浪费。简单的说，就是我们要做一双筷子，我们预估它会被使用很多次，所以我们把这双筷子做得很结实；但是后来实际情况是，这双筷子就只用了一次，这明显造成了一些浪费，远不如一开始做一双一次性筷子划算。
我们必须清楚“读复用”是需要付出一定代价的。所以如果严格地说，软件设计的本质是追求“有效复用”，

> 尤其对于一些有代码洁癖的人，“过度设计”会经常发生，他们在编写代码的时候习惯会对未来预留一些扩展，但一旦与预期不符，就出现了“浪费”。我个人认为，轻微的“过度设计”是可以接受的，只有不做设计才永远不会过度设计！但如果总是频繁出现“过度设计”，那么我们应该引起重视，看下自己的设计理念是否过于偏激，加以纠正即可。


相比于写复用，读复用的效果也更为明显。
在实际项目中，“读复用”很差的代码常见的表现是：一个很小的业务改动，会引起大范围的改动甚至改动非常困难。主要原因是各模块/类纠缠不清，耦合严重（代码僵硬）。最终即使修改的总代码行也不太多，但由于影响到多个模块，我们需要理清很多历史逻辑，导致最终花费的工作量很多。
之所以工作量大，是因为很多时候：**改是一个质的问题，改多少是一个量的问题**
对于一个设计糟糕的系统/模块/类来说，即使只修改一行代码，代表着你要阅读大量的历史代码，然后精准的找到这行代码的修改之处。修改完之后再进行重新编译，打包，测试，部署等等，整体工作量往往非常庞大。
而具有良好“读复用”的代码或模块往往具有更好的稳定性，可以让每次需要修改的代码非常少而且集中，很多时候甚至只需要增加一些代码而且不需要改动任何历史代码，虽然最终可能写的代码也没有变少，但是整体节省的工作量却非常可观。

而且，可以“读复用”的模块和代码因为其良好的高内聚低耦合性，一般都能被“写复用”，这也导致“读复用”变得尤为重要。


### 复用的前提

活字印刷术其实能很好的说明软件复用。

以前出版书籍最开始都是靠手抄，后来科技进步，出现了雕版印刷术，可以用印刷代替手抄，效率有了明显提升。但是这样会有个问题，就是每出一本新书的时候，都要重复刻板子，工作量非常大；一旦出现了错字，也要重刻。于是后面又出现了活字印刷术，活字印刷术相比于印刷术其实并没有技术上的创新，它只是一个简单的复用技巧，把所有常见的字都刻几份，通过组装字块到一块板子里进行印刷，这样每次出新书就可以复用这些字块，不用再重新刻板子。另外，由于字块过于分散每次拼板子也有点费时，于是我们还会把一些常用的词语合起来做成一个大的字块，这样找字块和拼字块的效率会略高一些。

印刷术中的“写复用”相当于共用字块。比如很多书籍都包含同一个字，为了共用，我们不得不把这个字拆出来做成单独的字块。
“读复用”则相当于希望修改某个字时不会影响其他字。比如有一个字刻的不好看，想改一下，如果是雕版印刷术，整块板子都得重刻；而活字印刷术，只需要修改一个单独的字块。

可以看出，无论是“写复用”还是“读复用”，第一步必须先拆。软件上的复用也是如此。
写复用：
有时候一个公共函数太大，会发现其中仍然还有可共用的代码，则需要再拆；而如果公共函数都拆的很小，很可能每个地方都需要调用好几个公共函数才能完成业务逻辑。
- 拆解的粒度过小，复用起来会略显困难。
- 拆解的粒度过大，可复用性会略有降低。

读复用：
如果两个事务纠缠在一起，是没法“隔离变化”的，所以“读复用”的第一步也是拆解，然后通过一些解耦的手段来优化两者之间的依赖关系。
在活字印刷术中，解耦的手段便是一套刻字的标准：字块的大小，字刻在字块哪个位置，居中还是靠上等等；如果不定义好这套标准，会导致字块拼不起来或者拼起来不好看。这套标准会让各个字块独立解耦，关于这种技巧后面的章节会有详细描述。

对于复用的理解会体现在我们的每一行代码中，比如下面这个函数:
```
public static void setUrl(SipRequest request, String str) {
    String url = null;

    /**
     * 一段解析str的代码, 并将结果赋值给request的url属性;
     */
    // some code

    request.setUrl(url);
}
```
大致逻辑是，str是一个url，需要进行一些解析或校验，然后赋值给SipRequest的url属性；
这个函数写的其实并不好，复用性较差。比如现在有个HttpRequest也要做相同的处理，该怎么办?
由于HttpRequest和SipRequest是三方件中的类，它们没有共同的基类，我们也无法修改它们。很多时候对于偷懒的程序员，大都会拷贝粘贴另起炉灶再写一个函数：
```
public static void setUrl(HttpRequest request, String str) {
    String url = null;

    /**
     * 一段解析str的代码, 并将结果赋值给request的url属性;
     */
    // some code

    request.setUrl(url);
}
```

其实这段解析url的代码是完全相同，是完全可以共用的。如果具有一些“复用”思维，这个函数一开始就应该写成这样：
```
public static String parseUrl(String str) {
    String url = null;
    
    /**
     * 一段解析url的代码, 并将结果赋值给url;
     */
    // some code
    
    return url;
}
```
request.setUrl(parseUrl(str))则是一件与解析url毫不相干的事，应该挪到别处。

最开始的setUrl函数本身是违反了设计原则的，他做了SipRequest的setUrl和解析url两个事情，这种写法会让函数难以复用。实际工作中，这种例子到处可见，很多时候我们还难以发现，而且大部分人都会犯此种错误，其中不乏一些常年将设计理论挂在嘴边的老程序员；同样，也有一些年轻的程序员，代码写的非常优雅。
所以如果某个大师满口挂着分层、解耦，但是写出来的代码丑陋不堪，我大概是不会相信他真的理解了这些设计理念，毕竟“抽象”，“开闭”，“解耦”，“分层”这些词永远都政治正确而且涵盖极广，在任何场合使用都不会显得lower或者愚蠢。而那些有着良好代码品味的年轻人，即使从未接触过设计方面的理论，我想在TA的心里已经有了“好代码”的标准，唯一缺少的只是一些点拨或顿悟。
这两种人我都见过许多。

对“复用”的理解其实最终体现的是我们对软件设计的理解，设计不仅仅是高屋建瓴，也体现在一行一行代码中。很多人不写好当前的每一行代码，却一味着要当架构师，其实是一种空中楼阁的行为。


#### 3. 总结
**软件设计的本质是复用**

软件设计能做的只能是通过朴实的“复用”来减小工作量：要么共用一些写过的代码，要么少读少改一些之前的历史代码。
我们经常挂在嘴边的“高内聚低耦合”，“抽象”、“可扩展性”，“开闭”都只是软件设计所追求的表面现象，如果最终不能**有效复用**，这些所谓的“灵活性”毫无意义。

**拆解是复用的前提；复用是拆解的目的。**
拆解的好坏也直接决定了可复用的上限。拆解是评价架构师水平的第一标准，也是软件设计领域最为重要也最困难的概念。
除了设计师本身的技术能力和经验外，拆解的好坏还与业务强相关。所以，一个优秀的设计师必须对本领域的业务有非常深刻的理解。


