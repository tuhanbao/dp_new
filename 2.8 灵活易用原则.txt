2023.3.27： 共用会带来耦合，即不灵活；——灵活易用原则


运动员和厨师


依赖组合和继承：复用的是对象之间的绑定关系

依赖：想换厨师就换，随时换，随时指定；但每次都得传参。非常灵活，不好用
组合：一次性传参，不支持并发，可换：适度灵活，适度好用
继承：不可换，很不灵活，但非常好用，都不关心。（继承和写死的组合是相同的效果）

抽象层次：复用的是对象的共性
抽象的越高，越灵活，但是不好用，你需要自己实现更多的细节；  装房子，只有框框，那你要自己装
抽象的月底，很死板，不好改，但是很好用；   精装房；


灵活易用原则的本质：
复用会带来耦合。这里的复用和我们整本书讨论的复用不同，软件设计提到的复用，指的是代码上的复用，而服用带来耦合是广义的复用，比如内存复用。


两个函数：  共用不灵活，拆开灵活   （代码上的写复用）
依赖组合继承 依赖各玩各的灵活，组合次之，继承最不灵活但是共用。  （绑定关系的复用）
抽象：依赖高度抽象复用，对调用者来说好用（复用），对使用抽象的人来说僵硬；依赖细节不能复用但灵活；（代码上的读复用）

所以：
灵活性指的是可复用性，是否能被更多的人使用；
易用性指的是我使用它需要做出的自定义处理，以及修改这个软件实体的难度；


人天生会优先选择简单的方式，所以我们的代码平常看到的都是偏易用性。因为满足当下就好了，管他灵不灵活，别人能不能用，以后能不能用。


复用带来扩展性，但是个性下放导致不好用，而复用的内容本身变得极度不灵活。
其实这句话和之前的想法没有冲突，只是要好好重新定义概念。

兼容更多的场景和复用完全是两码事，比如Animal比Person是兼容更多的场景，但是Animal假设只有两处代码公用，但是Person有一万处。其实Person会更不容易被更改，它的代价太大。
所以，如果把兼容更多的场景定义为灵活性，那么灵活性和易用性是互斥的。但是复用带来耦合这句话和上一个结论可能就没有关系了。

依赖和组合相比，前者是灵活性更强，所以易用性很差。我之前思考进入过一个误区，认为组合是复用了两个对象的绑定关系，所以导致其不灵活，这是一个错误的观点，复用会导致使用方彼此绑定，大家一改都改，要么都不改，想要灵活就很难。

复用包含的共性越少，灵活性更强，易用性越差；

复用包含的内容越多，灵活性更弱，易用性越好。

这一点抽象和公共函数是很好理解的，但是依赖和继承呢？两个地方调用依赖，没有复用，两个地方调用继承，复用了强绑定关系。