**依赖倒置原则（Dependence Inversion Principle，DIP）**：高层次的模块不应该依赖于低层次的模块，它们都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象


### 1. 什么是依赖倒置
先分享一段笔者自己的亲身经历。

在笔者小的时候，每个村都有专门的邮递员，如果要寄信是需要把信自己送到邮递员家的。当时我父亲在南方打工，我母亲会经常让我把写给父亲的信送到邮递员李四家，一直持续了好几年。但是随着打工潮兴起，村里大量的年轻人都出门务工，李四也是其中之一。所以有一次我去寄信，李四家人告诉我李四已经不是邮递员了，现在新的邮递员是村里的王五，于是我需要重新跑到王五家。可是过了一阵子，王五也出门务工了，邮递员又换成了另外一个，我还得重新跑。我记得再过了一段时间，村里就没有邮递员了，而是在小卖部那里修了一个邮筒，寄信就扔邮筒里面，镇上的邮递员则会定期每隔几天来村里的邮筒取信。

这是一个很典型的依赖倒置原则的例子：
寄信这个活动，主要存在两种角色：寄信人和邮递员。
最开始寄信人强依赖于邮递员，寄信需要送到邮递员家。这种模式缺点比较明显，邮递员换了很麻烦。直到后面增加了邮筒，寄信人不再直接依赖邮递员，而是依赖一个站着不会动的邮筒。

![](C:\Users\A\Desktop\Design-Pattern-main\image\image-20211129161135932.png)

// TODO

上面的邮筒，可以让邮递员再怎么变化，都不会影响到寄信人。这种将寄信人直接依赖邮筒，改为寄信人和邮递员互不依赖，两者都依赖于邮筒的过程，正是“依赖倒置”。

### 2. 为什么要依赖倒置

我们先看一个例子：现在有一个运动员类，它有两个方法，一个是打球，一个是游泳，打完球运动员要喝番茄汤，游完泳他要吃炒饭。简单使用代码描述则是如下：

```
// 代码片段2.3.1
public class Athlete {

	public void playBall() {
		// 打球
		// some code...
		
		// 做番茄汤
		Soup soup = ...
		// some code...

		// 喝汤
		// some code...
	}

	public void swim() {
		// 游泳
		// some code...
		
		// 做蛋炒饭
		FriedRice rice = ...
		// some code...

		// 吃蛋炒饭
		// some code...
	}		
	
}


```


很明显，上面的代码不是很合理，我们把运动员和厨师的功能揉在了一起，无论是做饭的逻辑更改，还是运动的逻辑修改，都需要修改Athlete类。
> 实际工作中的代码往往都远比代码片段2.3.1中的例子要复杂，而且代码界限也不会如此清晰，这种将不同逻辑功能搅合在一起的方式会给代码维护带来很大困难。

通过前一章节的学习，我们按照单一职责原则将做饭的逻辑拆出去即可：

```
// 代码片段2.3.2
public class Athlete {

	private Chef chef = new Chef();

	public void playBall() {
		// 打球
		// some code...
		
		// 做番茄汤
		Soup soup = chef.cookSoup();

		// 喝汤
		// some code...
	}

	public void swim() {
		// 游泳
		// some code...
		
		// 做蛋炒饭
		FriedRice rice = chef.cookFriedRice();

		// 吃蛋炒饭
		// some code...
	}		
	
}


public class Chef {

	public Soup cookSoup() {
		// 做番茄汤
		Soup soup = ...
		// some code...
		return soup;
	}

	public FriedRice cookFriedRice() {
		// 做蛋炒饭
		FriedRice rice = ...
		// some code...
		return rice;
	}		
	
}

```

现实中大部分的问题都可以上面这种简单的拆分解决，这样整改后便实现了两个变化因子的变化隔离：做饭的逻辑如果发生变化则修改Chef类，运动的逻辑发生变化则修改Athlete类，二者互不影响，而且Chef类还可以给其他类共用。

看起来这已经达到了我们想要的效果，只要打球和游泳的逻辑不发生变化，Athlete类就不会需要修改。但实际情况并不总是如此，有一些场景：比如当运动员要“换”厨师时Athlete类还是会被影响。

正常情况下，运动员如果想换口味，修改Chef类就好了，完全没有“换”厨师的必要。但实际工作中经常会出现一些场景，会逼迫我们不得不“替换”厨师，比如：厨师并不是运动员独享的，这就像一个餐厅一样，你一直吃中餐，突然一天想吃西餐，你不能要求之前一直给你做饭的中餐厨师给你做西餐，而是应该去换一个做西餐的厨师。在代码中的表现就是，Athlete类不能随意修改Chef类中的做汤和做饭的逻辑，因为Chef类已经被很多其他类使用，如果只是想把番茄汤换成土豆汤还好，但运动员突然想吃泰式冬阴功汤，其他类都接受不了；又或者运动员今天要吃番茄汤，明天要吃冬阴功汤，后天又要吃番茄汤，我们不可能将Chef的代码逻辑改来改去；此时我们必须写一个新的厨师类来实现这种新式菜肴的烹饪；

```
// 代码片段2.3.3 一个新的厨师
public class NewChef {

	public Soup cookNewSoup() {
		// 做冬阴功汤
		Soup soup = ...
		// some code...
		return soup;
	}

	public FriedRice cookNewFriedRice() {
		// 做菠萝炒饭
		FriedRice rice = ...
		// some code...
		return rice;
	}		
	
}


// 旧厨师的代码需要保留
public class Chef {

	public Soup cookSoup() {
		// 做番茄汤
		Soup soup = ...
		// some code...
		return soup;
	}

	public FriedRice cookFriedRice() {
		// 做蛋炒饭
		FriedRice rice = ...
		// some code...
		return rice;
	}		
	
}

```

当运动员要“换”厨师时，我们发现单纯的拆解已经无法解决问题，即使Athlete类本身负责的打球和游泳逻辑并没有产生任何变化，Athlete类也必须产生变动

```
// 代码片段2.3.4
public class Athlete {

	private NewChef chef = new NewChef();  // 需要更改厨师类型

	public void playBall() {
		// 打球
		// some code...
		
		// 做番茄汤
		Soup soup = chef.cookNewSoup();  // 新厨师的方法名也发生了变更

		// 喝汤
		// some code...
	}

	public void swim() {
		// 游泳
		// some code...
		
		// 做蛋炒饭
		FriedRice rice = chef.cookNewFriedRice();  // 新厨师的方法名也发生了变更

		// 吃蛋炒饭
		// some code...
	}		
	
}
```


最开始的代码只有两个变化因子：运动的逻辑和做饭的逻辑，我们将其分别放在了Athlete类和Chef类中，即使后面多出了一种泰式做法，我们也将其放在了NewChef中，运动的逻辑发生变化就修改Athlete类，做中餐的逻辑发生变化就修改Chef类，做泰餐的逻辑发生变化则修改NewChef类，三者互不影响。

但现在多了一个新的变化因子，运动员和厨师的关系也可能发生变化：一会依赖Chef，一会依赖NewChef。当这种依赖关系成为变化因子时，我们发现通过单一职责原则的拆解手段已经很难解决。Athlete本应该只负责运动的逻辑，但这种依赖关系的变化却实实在在影响到了Athlete类，而且甚至未来还可能要求厨师不能由运动员自己决定，比如教练要求运动员工作日吃中餐，周末吃泰餐；如果再增加更多种类的厨师，这将会给Athlete类的维护带来噩梦。

要解决这一类问题，正是**依赖倒置原则**的存在价值。

### 3. 如何依赖倒置

假定A和B是两个软件单元模块，为了方便讨论，我们把A依赖B使用箭头表示如下：
A→B

如果A->B这种关系不太稳定时，会导致A的代码不够稳定，我们将这种因为依赖关系发生变化导致A修改的问题简称为"**AB问题**"。

而要解决**AB问题**，即未来将B替换为B1,B2或者Bn时，让A不会受到任何影响，要达成这种效果，只有一种方式，我们必须让A不能感知到B的任何细节，用代码来说则是在A的代码中不能出现B的任何影子，也就是让A不能直接依赖B。

但软件在运行时，只要A需要调用B的功能，不管如何辗转轮回，电脑的指令一定会以某条路径从A模块传到B模块。所以如果A→B，只要功能最终要在B中实现，这种依赖关系就不可能消除，只能转移。

我们可以先罗列一下所有可能的依赖转移方式：
1. A→C→B : 增加一个中间层C，让A间接依赖于B；
2. A→C←B : 增加一个中间层C，让AB都依赖于C；
3. B→A ：  让B反向依赖于A；
4. A←C←B : 增加一个中间层C，B依赖于C，C依赖于A；
5. A←C→B : 增加一个中间层C，C依赖于AB，而AB互不依赖；

当然，如果A和B是非常庞大的软件系统，我们可以增加更多的中间层，罗列更多的依赖转换方式。但是无论加多少种，也只是这些基本转换的组合或变形：

我们仍然以本章最开始的寄信为例来说明这些依赖关系的转移，其中A是寄信人，B是邮递员。那么最开始的场景是：
- A→B：   A必须送信到B家里去才能完成寄信，这种情况下A强依赖B，B换了地址，A就会受到影响。

后面的5种依赖关系转变如下：
1. A→C→B:  B总是换地址，A受不了了，找了个地址固定的C当跑腿，每次A把信送给C，再让C代替送信给B。这种情况下C就遭殃了，B换了地址C会受到影响，但不管怎样，A变得轻松了，他只需要把信送给C就行。
2. A→C←B： B总是更换地址，C受不了不干了，A和B商量了一下，找邮局修了一个邮筒C，A每次都把信扔到邮筒里，B也直接去邮筒取信，A和B都只依赖于邮筒。但不管怎么说，B以前是躺在家里收信，现在至少要隔一段时间跑一次邮筒取信，所以B比以前难受了。
3. B→A ：  过段时间，A发财了，A送信到邮筒去都懒得跑，让B直接来家里取信；这样B就惨了，每次都要跑到A家里去取信，而且A要是换了地址，B也得受影响，但很无奈，A给了B太多钱。
4. A←C←B： A总是搬家，把邮筒也跟着搬来搬去，B跟着跑了几次也烦了，干脆也去找了个地址固定的C当跑腿，让C代替B去A家里取信，B再去C那里取信；这样A要是换了地址，B不会受到影响，但跑腿的C让然受罪。
5. A←C→B : 过了段时间，B也发财了，B连去C那里取信都懒得跑了，让C从A家里取完信，然后再让C把信自己送到B这里来。这种情况，A和B啥都不用干了，就C一个人两头跑，A和B任意一方换了地址，C都得被影响。

如果把这五种方式的演变方式归纳一下，其实只有两种手段：
1. **中间人**：找一个跑腿的帮自己干活。
- 在第1种A→C→B转换中，C是A找的跑腿；
- 在第4种A←C←B转换中，C是B找的跑腿；

2. **定标准**：让别人按照自己的规则行事。
- 在第2种A→C←B中，C（邮筒）是A和B共同定下的标准，两人都要遵守；
- 在第3种B→A中，A过于强势，直接定下了单方面的标准让B遵守，就像是将邮筒搬到了自己家里一样；
- 在第5种A←C→B中，B也使用了同样的手段，B给C（跑腿的）定下了单方面的标准，让C跟随自己的地址跑；


**定标准**和**中间人**是软件设计中最重要的两个实施手段，依赖倒置原则的核心正是**定标准**


#### 3.1 **定标准**的代码实现

我们接下来将使用**定标准**的手段来解决运动员换厨师的问题。

运动员依赖于厨师，但是厨师需要做到可更换；就像寄信人依赖邮递员，而邮递员地址可更换一样，我们需要先修一个邮筒，这个邮筒便是我们需要定义好的标准：

```
public interface ChefInterface {

	Soup cookSoup();

	FriedRice cookFriedRice();
	
}

```

然后让运动员和厨师都遵从我们定义好的标准：

```
// 代码片段2.3.5
public class Athlete {

	// 构造方法或setter方法设置
	private ChefInterface chef;

	public void playBall() {
		// 打球
		// some code...
		
		// 做番茄汤
		Soup soup = chef.cookSoup();

		// 喝汤
		// some code...
	}

	public void swim() {
		// 游泳
		// some code...
		
		// 做蛋炒饭
		FriedRice rice = chef.cookFriedRice();

		// 吃蛋炒饭
		// some code...
	}		
	
}

// 新的厨师的方法名必须与标准保持一致
public class NewChef implements ChefInterface {
	
	@Override
	public Soup cookSoup() {
		// 做冬阴功汤
		Soup soup = ...
		// some code...
		return soup;
	}

	@Override
	public FriedRice cookFriedRice() {
		// 做菠萝炒饭
		FriedRice rice = ...
		// some code...
		return rice;
	}		
	
}


// 旧厨师也要实现ChefInterface这个标准
public class Chef implements ChefInterface {

	@Override
	public Soup cookSoup() {
		// 做番茄汤
		Soup soup = ...
		// some code...
		return soup;
	}

	@Override
	public FriedRice cookFriedRice() {
		// 做蛋炒饭
		FriedRice rice = ...
		// some code...
		return rice;
	}		
	
}
```


这样修改之后，Athlete不再直接依赖Chef或者NewChef。如果Athlete想变换口味，我们只需要给Athlete传入相应的厨师即可，我们甚至可以创建更多不同种类的厨师给运动员做饭，Athlete都不会受到影响。

通过**定标准**确实可以将运动员和厨师不产生直接依赖，它们都只依赖一个没有任何实现的抽象接口CharInterface。这确实是一种好的状态，但细心的读者会发现，代码片段2.3.2或代码片段2.3.4是在Athlete类中直接初始化厨师对象的，而代码片段2.3.5没有，因为他不能直接依赖具体的厨师类，所以ChefInterface chef = new Chef()或ChefInterface chef = new NewChef()这种代码不允许出现在Athlete类中。

但是厨师最终还是要实例化的，它终究要存在于某个地方，总要有某个类或者函数承载运动员和厨师绑定关系这个变化因子：它需要将ChefInterface实例化并通过setter方法或构造方法传给Athlete的chef变量。
````
Athlete athlete = new Athlete();
ChefInterface chef = new NewChef()
athlete.setChef(chef);
```

在实际工作中，我们一般将这种初始化放在业务决策的地方，比如运动员吃西餐还是中餐由教练决定，那么就由教练来承担这个变化因子；有时，这种决策也会放在整个系统的启动模块，或者业务的初始化加载模块中。java生态中最著名的spring框架在最开始的时候正是靠着这一手（依赖注入）坐上了java开源件的宝座，它一人独自承担了类与类之间的绑定关系。
> 在早期spring版本，我们需要在配置文件里面配置上实现类的完整类名，而新版的spring，连配置也省了（参考srping@Autowired用法），非常方便。

#### 3.1 依赖倒置原则的应用

**依赖倒置原则**在软件代码中最常见的体现就是通过抽象一个interface或者abstract class来解决**AB问题**；但如果仅仅从代码角度去理解**依赖倒置原则**其实会过于狭隘，和**单一职责原则**一样，**依赖倒置原则**也是一个可以应用于各行各业的设计思想。

- 在软件代码中，**依赖倒置原则**所定的**标准**也可以体现为一个**字符串**：

笔者之前做过一个项目，需要友商提供一个jar包实现一个功能。我们当时是甲方，我们便直接在代码中写死了类名和函数名，然后通过反射调用友商的功能，所以友商就必须严格按照我们规定的类名，方法名来实现他的功能。这种方式看起来很lower，但它确实可以让我们非常方便的在多个友商间进行选择，我想用友商甲的功能，就加载友商甲的jar包，想用友商乙的功能则加载友商乙的jar包。

```
// 我司的代码
public class A {

	public void doSomeThing() throws Exception {
		Class cls = Class.forName("com.xxx.B");
        Method method = cls.getMethod("doForMe");
        method.invoke(cls.newInstance());
	}
}

// 友商只要在jar包中包含一个com.xxx.B的类，并包含一个doForMe的无参方法即可。
```

在上面的例子中，标准则是一个类名和方法名，他一样可以解决我司不和任何一家友商强绑定的问题，而且这种方式在早些年代非常方便而且实用。

- 而两个进程或者服务之间，这个**标准**则体现为一个消息中间件或者服务注册中心。
最开始A进程直接调用B进程，A需要感知B进程的网络地址，如果B进程换了地址，亦或是未来与C进程进行交互都会非常麻烦。但如果使用了MQ（消息中间件），所有进程只要都遵守消息的发送和接受规范，便可以轻松实现各进程之间的互相调用。此时**标准**体现为消息组件的接口规范。
同理，不同服务之间的相互调用，也需要建立一个公共的服务注册中心，实现各服务之间互相解耦，此时**标准**则体现为一套服务注册和发现机制。

- 在不同的厂商之间，这个**标准**则往往体现为一个国际标准或者通用协议。
比如交管局的一个管控中心要可以监控所有的摄像头，而目前的摄像头厂家又五花八门，为了不和特定的某个摄像头厂家绑定，那么就必须有一套定义了如何操控摄像头和流传输的标准协议。在这种场景中，**标准**体现为类似于GB28181的通用协议。


- 乐高积木

乐高积木有很强的扩展性，我们可以任意挑选不同批次不同包装里面的两个小零件，基本都能拼在一起，即乐高积木实现了不同零件之间的解耦，而其核心便在于乐高定义了一套非常稳定的接口标准：
![](C:\Users\A\Desktop\Design-Pattern-main\image\legaojimu.jpg)

定义这套标准并不难，我们只需要定义好一个”乐高单位“的高度和宽度，凸点和凹点的深度和直径即可；但是试想一下，如果没有这套标准，每套积木都各玩各的，有的长一些，有的短一些，这将对乐高积木的生产和设计带来多么灾难性的后果。


可以看到，无论是在软件工程中还是我们的实际工作生活中，但凡我们要实现某种关系解耦（不强绑定某个固定的乙方，达到“可替换”），比如上面四个例子中：“我司”可以随意替换友商、一个进程或服务之间可以随意调用另外一个其他进程或服务、交管局可以选择任何一个厂家的摄像头、以及乐高积木不同零件之间的随意组装，都一定会出现**标准**的影子。


### 4 依赖倒置原则的陷阱

至此为止，我们都在讨论**依赖倒置原则**带给我们的好处。但是获得这种好处的前提条件是**标准**必须非常稳定，否则一旦**标准**出现变更，后果将非常严重。比如中我们把代码片段2.3.5中的ChafInterface定义的函数换了一个名字：
```
public interface ChefInterface {

	Soup cookMySoup(int salt); // 以前叫cookSoup，现在不仅改了函数名，还加了个参数控制放多少盐

	FriedRice cookFriedRice();
	
}
```
这时，运动员和所有的厨师都需要进行修改！

但会有人提出反对意见：一个被很多人使用的接口如果出现了变更，影响确实很大，但是接口再怎么也比具体类稳定，如果接口发生了变更，一般都是因为业务发生了变更，这种情况本来就不得不改。

学过java的对MVC应该都比较清楚，一般这种项目中都会有Service和ServiceImpl类成对的出现，比如：
```
public interface UserService {
    void saveUser(User user);
}

public class UserServiceImpl implements UserService {
    @Override
    public void saveUser(User user) {
        // TODO
    }
}
```
现在让我们发自内心去思考一个问题，到底是Service“依赖”ServiceImpl还是ServiceImpl“依赖”Service?
实际情况是:当需求发生变更时，我们修改的主体一定是ServiceImpl，而Service只是被动去做同步适配而已。更不用说调用Service的Controller类了，它并不会因为它是依赖的一个抽象接口Service而幸免于难。

> Service类存在的必要性与实际项目有关，如果一个Service明显可能存在多个实现，比如将来要将本地调用的Service切换为远程调用的Service等，那么定义Service接口是有意义的。但大多数工程，Service永远都只有一个实现，这种情况下Service接口的定义纯属多余，它只会让你在每次修改ServiceImpl时，还多修改一次Service接口，除了让你多了一些代码产出，毫无意义。
> 
> 还有一种特殊的情况：当项目使用了基于接口的动态代理，Service接口的存在也是必要的。

所以，接口有时候也并不一定比实现类稳定，它有时候甚至会毫无原则的跟随实现类变动。

举个例子，甲公司与乙公司签订合同共同开发一款软件，其中双方的架构师经过讨论，定义了一套清晰的接口文档，于是，双方的开发人员都可以按照接口文档进行独立开发和测试。
最终联调的时候，发现某个接口甲公司实现的不对，并未按照接口文档编写，乙公司开发人员要求甲公司开发人员按照接口文档重新修改实现。但是甲公司架构师经过评估发现，如果此时修改会导致他们工作量很大，所以坚持让乙公司进行修改。
乙公司开发人员小王感到很不满，说接口文档就是这么定的，我们是按照文档做得，是他们弄错了，凭什么我们改；甲公司架构师得知此事后，于是按照甲公司开发人员的实现方式重新去更新了接口文档。

我相信这种事情天天都在世界的某个角落以某种形式发生，而且我也知道这种事情的结局一定是“乙方”修改，因为对方是“**甲方爸爸**”
这种结局并非意料之外。其实换位思考下，如果我们掌握着主导权，肯定也会选择对己方更有利的决策。

所以，不仅是代码中的接口会变，就连白纸黑字的接口文档，国际标准等等在未来的某一天都是极可能发生变化的。而且一旦这个**标准**偏向于其中一方，在**标准**发生变更时，另一方就成为了受害者。这也是很多公司不惜重金也要进入某某协会，某某联盟或某某标准委员会的原因，因为掌控了标准，就掌控了主导权。
> 好在我们常常所做的软件设计，都只是内部A→B问题，无论是A，B还是接口C都由我们自己控制，这样一般不会存在C的偏向问题。但即便如此，因为某些需求的加入，我们也不得不去修改C，然后同时大篇幅的去修改接口的实现者B和调用者A。产生这种情况，有时候是接口定义的不够合理，有些时候却是真的无法避免。

从上面两个例子可以看出，依赖倒置原则的几种常见的理解：面向接口编程或面向抽象编程，其实是不准确的。因为当接口和抽象不稳定时，依赖倒置原则并不能解决任何问题。更准确的说，依赖倒置原则的本质是：面向稳定编程。我们让寄信人依赖于邮筒，并不是因为邮筒有多“抽象”，而是因为它没有脚，非常稳定。
只要一个类或模块足够稳定，我们就可以放心的去依赖它，与它是不是标准，是不是抽象，是不是接口没有半点关系。依赖倒置原则之所以建议我们依赖抽象，仅仅是因为抽象大部分情况下比具体稳定而已。

我们常用的String类，就是一个非常具体的实现，但从来不会有人建议我们去使用它的抽象接口CharSequence，甚至可能很多新手都不知道CharSequence的存在。

如果我们依然狭义的去理解依赖倒置原则，那么本章在讲完**BA转换**就应该结束了。但如果将依赖倒置理解为：面向稳定编程，我们会惊奇的发现这条原则的伟大之处，它几乎一人独揽了所有设计模式的半壁江山，而BA转换也仅仅只是其核心手段之一。


### 面向抽象编程的谬论


#### 3.3 ACB转换

ACB转换相比BA转换，要容易理解很多。
在我个人看来，ACB转换是所有设计手段中最高明的一种。原因无他，简单即美！

```
public class A {
    public void doSomething(B b) {
        b.hello();
    }
}
```
把上面的代码进行ACB转换：
```
public class A {
    public void doSomething(C c) {
        c.hello();
    }
}

public class C {
    private B b;

    public C(B b) {
        this.b = b;
    }

    public void hello() {
        this.b.hello();
    }
}
```

似乎有点多余。但ACB转换确实就是如此，没有任何花里胡哨：本来A直接依赖B，变成A依赖于C，让C帮忙去调用B。如果没有一些具体的例证，甚至让人觉得是不是多此一举。



很久之前笔者曾在XX公司就职，当时对三方件的管理非常严格。其中有一条规则是如果某个三方件有新版本发布，旧版本会在一年后被列入“黑名单”，必须弃用。

当时部门很多团队都使用了apache的commons-lang包，这个三方件提供了大量的工具类，非常好用。但是commons-lang后面进行过一次更新，所有的3.x版本在包路径上加了数字3，比如

org.apache.commons.lang.StringUtils

更名为

org.apache.commons.lang**3**.StringUtils

commons-lang的工具类在我们团队有大量使用，所以，全部门不得不将所有依赖commons-lang的class修改一遍。修改内容也比较简单，就是重新import一下就好，当然，机智的程序员会使用IDE的全局替换功能或者写一个小工具。但是对于一个质量要求很高的产品而言，这种大面积的改动仍然会花费不少工作量，比如担心出现人工上的失误，对所有的改动处进行覆盖测试等等。

唯独我们团队最为轻松，我们所有的业务代码都没有直接使用commons-lang，而是使用我们自己封装的工具类。比如字符串判空，我们自己的工具类写法如下。

```
public class StringUtil {
    ......

    public static boolean isEmpty(String s) {
        return org.apache.commons.lang.StringUtils.isEmpty(s);
    }

    ......
}

```

虽然实际上也调用的是commons-lang的内容，但是三方件更新后，我们只需要更改这一行代码就好。



当然，这种额外封装带来的价值有待商榷，笔者也并非建议我们使用三方件时都去隔离一层。这里仅仅只是一个例子，说明ACB是如何发生作用的：当有成百上千个A依赖同一个B的时候，抽出一个C来隔离B的改动，有时候会给你带来意想不到的效果，况且这种手段是如此的朴实无华。


如果我再举一个例子，大家一定耳熟能详：Java本身。
A代表着java语言开发的所有软件，这是一个非常庞大的群体；
B则是操作系统；
C便是jdk;

从依赖关系看，A依赖C，C依赖B，根据依赖传递原则，A依然依赖B，那么java语言所开发的软件仍然是依赖操作系统的；但是无所谓，依赖就依赖，你改我跟着改就好了。所以当我们更换操作系统，或者操作系统有重大版本更新时，我们也必须更新我们的软件包，但是这种改动微乎其微，只是更换一下相应操作系统版本对应的JDK就好了，亦或是把32位的JDK换成64位。
试想一下，如果没有JDK这层隔离，让业务代码直接依赖了操作系统底层的API，该有多恐怖。各位可以咨询身边C语言相关的同事，就说如果产品经理让他把一个写好的软件从linux切换到windows，会有多大影响。但因为Java语言所做的这一层隔离，可以让上层所有的java语言开发出来的软件完全不用关心底层操作系统的变化。

可以说，正是ACB转换成就了java的跨平台！

> 有很多刚学java的新手认为java是跨平台的，会误以为jdk与操作系统无关。实际上JDK比它上面的任何应用程序软件都要关心操作系统，他需要针对不同的操作系统、不同的版本相应提供不同版本的JDK。

当然，ACB转换也有不足之处，很明显的是ACB转换并不能彻底解决依赖问题，即B更改时，C会受到影响（commons-lang的例子中，我们需要修改我们自己的工具类重新打包；jdk的例子中则是需要更换jdk版本）。但好处也非常明显:
// TODO 每个应该举个例子
- 简单粗暴，而且当A够多的时候，能实实在在的给你省掉很多工作量，只改一个C就好了；
- 能充当防腐层或隔离带的作用：当A是一个非常重要的模块时，我们可以通过增加一个小小的组件C来阻挡B对A的影响；
- 非常友好，没有门槛：它并不会强制要求B或A实现任何接口或标准，AB之间而且互不感知；
- ACB可以解决一些BA模式无法解决的问题，比如B不想实现你定义的接口或者A直接依赖于B的创建时，此时只能使用ACB。


ACB常见的有三种场景:
##### 1. B是一个类或者一个模块
我们使用一个新的类C将B包装起来即可，如果B是一个模块，那么C也会是一个模块。
简单的说，就是通过组合的方式来隐藏B。

有些情况下， 我们还可以将这种组合转换为继承，也可以达到同样的效果:
```
public class A {
    public void doSomething(B b) {
		// hello()方法未来变成了hi()
        b.hello();
    }
}
```


组合式的ACB转换，通过C隔离B对A的影响：
```
public class A {
    public void doSomething(C c) {
        c.hello();
    }
}

public class C {
    private B b;

    public C(B b) {
        this.b = b;
    }

    public void hello() {
        this.b.hi();
    }
}
```

继承式的ACB转换，同样可以通过C隔离B对A的影响：
```
public class A {
    public void doSomething(C c) {
        c.hello();
    }
}

public class C extends B {
    public void hello() {
        this.hi();
    }
}
```

总体来说，前者更灵活，后者更简洁。如果没有特殊情况，我们可以在条件允许的范围内随意选择，即使发现不合适，也可以在不影响A和B的情况下切换成另一种方式。


##### 2. B是一个函数
我们创建一个函数转调即可。

##### 3. B是一段逻辑
比如：
```
    public void method1() {
        // code block 1
        // ...
        // code block 2，same as code block 4
        // ...
    }

    public void method2() {
        // code block 3
        // ...
        // code block 4，same as code block 2
        // ...
    }
```
其中函数method1和method2是两个不同的A, B则是他们相同的那段逻辑(code block 2和code block 4是一模一样，而且他们本身就是同样的业务逻辑——即当他们需要修改的时候肯定会同时修改，注意，B代表的是代码块的业务逻辑，而不是代码块本身)；通过ACB转换，我们可以抽取一个公共方法shareMethod，即ACB转换中的C。这样一旦业务逻辑变化，以前需要修改多处A(method1和method2)，而现在只需要修改C(shareMethod)即可。
```
    public void method1() {
        // code block 1
        // ...
        shareMethod();
    }

    public void method2() {
        // code block 3
        // ...
        shareMethod();
    }

    public void shareMethod() {
        // code block 2
        // ...
    }
```

很多时候，我们抽取公共函数，就是一种ACB转换。

ACB转换，像极了一个大义凛然的英雄（C），为身后想要保护的人（A），扛下了所有的罪过。
如果以后有人说：“搞一个适配器”，“加一个中间层”，其实他这只是要加一个C而已，这并不神秘。

> ACB转换的存在让我对bob大叔《敏捷软件开发》一书中所提到的稳定性度量和稳定依赖原则产生过一些怀疑。无论是根据稳定性度量计算还是根据依赖传递原则，ACB转换中，B肯定都是要比C更为稳定的。既然如此，那么为什么我们原本依赖于更稳定的B，要将它改为去依赖一个相对更不稳定的C呢？最终我发现是我自己对ACB转换产生的误解，ACB转换从一开始就没有想过摆脱对B的依赖，C无论是附属于A模块还是B模块，本质仍然是A→B，他的目的并不是为了不依赖于B，而是更好的依赖B。

#### 3.4 ACB的另用
当存在关系A->B时，我们第一反应是A更为弱势，因为他依赖B。
在BA转换的陷阱一节中，其实有举过例子，实际情况中，谁更强势与谁依赖谁并没有必然关系，主要看谁是甲方。

比如甲方的模块A依赖了乙方模块B的api，虽然此时是A->B，但我们会发现B根本没有说话权。
- B因为自身原因想单方面修改接口，如果影响到A，A大概率会不允许B修改；
- A因为自身原因想当方面修改接口，它会毫无理由的要求B更改为它想要的接口；

所以ACB转换，在A弱势的时候，增加一个C可以隔离B对A的影响。
但当B弱势的时候，C同样也可以隔离A对其各种无理要求的影响。

代码举例则是这样：
```
public class A {
    public void doSomething(B b) {
        b.hello();
    }
}

```

A如果哪说，我不想要你的函数名叫hello，改成hi。
如果B已经被我们内部很多地方使用了，修改函数名影响很大，此时会很难办。但如果我们使用了ACB转换：

```
public class A {
    public void doSomething(C c) {
        c.hello();
    }
}

public class C {
    private B b;

    public C(B b) {
        this.b = b;
    }

    public void hello() {
        this.b.hello();
    }
}
```

此时改一下C，迁就下A就可以了，B并不会受到影响。

```
public class A {
    public void doSomething(C c) {
        c.hi();
    }
}

public class C {
    private B b;

    public C(B b) {
        this.b = b;
    }

    public void hi() {
        this.b.hello();
    }
}
```

所以可以看出，C在充当隔离层时，一般由弱势的一方添加用于保护自身。

#### 3.5 BA转换和ACB转换的比较

我们说依赖倒置的本质是隔离变化，那么我们可以先罗列一下B所有变更的场景，看下BA转换和ACB转换是否真的可以让A不受影响。
我们依然拿最基础的代码举例：
```
public class A {
    public void doSomething(B b) {
        b.hello();
    }
}

public class B {
    public void hello() {

    }
}
```

1. B只是修改其函数内部逻辑，不修改接口。
   无需解决，A本身就不受影响。

2. 使用一种新的实现方式B1代替B（或B修改类名）:
   BA转换可以完美解决， B1实现接口C即可：
```
public interface C {
    void hello();
}

public class A {
    public void doSomething(C c) {
        c.hello();
    }
}

public class B1 implements C {
    @Override
    public void hello() {

    }
}
```
ACB转换也能解决，改动C即可：
```
 public class A {
    public void doSomething(C c) {
        c.hello();
    }
}

public class C {
    private B1 b;

    public C(B1 b) {
        this.b = b;
    }

    public void hello() {
        this.b.hello();
    }
}
```
这两种方式都能很好的保护A。

3. B更改了接口（修改接口名或改变方法的传参、返回值）
BA转换无法做到，A和C都会受影响。
ACB转换可以在A不感知业务变化的情况下做到隔离，比如：
```
 public class A {
    public void doSomething(C c) {
        c.hello();
    }
}

public class C {
    private B b;

    public C(B b) {
        this.b = b;
    }

    public void hello() {
        this.b.hello1(); // 改变方法名
        this.b.hello2("", 1); // 改变传参
    }
}
```
即使修改返回值其实也不会影响到A，因为实际情况，C并不是一个单独的类，可以是多个甚至是一个模块，它会将B的所有信息都隔离开让A不感知。
比如：
```
public class A {
    public void doSomething(B b) {
        B1 b1 = b.hello();
        b1.do();
    }
}

public class B {
    public B1 hello() {

    }
}
```
ACB转换实际上如下：
```
public class A {
    public void doSomething(C c) {
        C1 c1 = c.hello();
        c1.doSomething();
    }
}

public class C {
    private B b;

    public C(B b) {
        this.b = b;
    }

    public C1 hello() {
        return new C1(this.b.hello());
    }
}

public class C1 {
    private B1 b1;

    public C1(B1 b1) {
        this.b1 = b1;
    }

    public void doSomething() {
        this.b1.doSomething();
    }
}
```

如果B的这些变更本身就涉及到A。比如，业务就是需要A多传一些参数，需要A调用B的新api完成一个新的功能等，这种ACB转换也无法解决。
这种改动就好比天要下雨， 娘要嫁人，你自己本身都要变，谁也没法保护你。
> 这种改动，其实可以通过预留多余的接口、使用json，Map之类的集合等方式保持一些可扩展性；如果不是对产品上线后改动特别敏感或者代价特别昂贵的项目，不建议做这种扩展预留。

至此，我们对**BA转换**和**ACB转换**做一些总结：
- 任何两个模块A和B，只要这个改动不涉及到A（A不感知这种业务变化），我们就可以通过合理应用BA转换和ACB转换，达到让B的修改对A不产生影响或影响可控的目的。
- BA转换和ACB转换大部分场景都是为了保护A，即减少或消除B的变化对A的影响（隔离变化）；ACB有少数场景是为了保护B。
- 他们都给A提供了相对稳定的接口，前者提供的接口需要B遵守并实现，后者只是当方面提供给A使用；
- BA转换中C经常作为一个高层模块或A的附属模块，可以让A彻底不依赖B；ACB转换C经常作为A的附属模块，A依然会间接受到B的影响，但影响可控。
- 一旦B发生变化，BA转换可以让A不受任何影响，但是调用侧（client角色）会受到牵连；ACB转换也可以让A不受影响，一般都是C会受到影响，有时也可能是调用侧（使用client角色组装C的场景）。
- BA转换可以在运行时动态将B切换为另一种实现B1，而单纯的使用ACB则无法做到，一般都需要修改代码。
- BA转换中C由强势的一方掌控，ACB转换中C由弱势的一方掌控。


满足以下所有情形，使用**BA转换**：
- 情形1： B是可控模块，即我们可以要求B按照我们定义的接口去实现。
- 情形2： B可能存在多种实现方式，即未来可能会有B1，B2出现；或者A→B违反了稳定依赖原则（A是更高层的模块，不应该依赖于B）
- 情形3： 不涉及对B对象的直接创建；

存在以下情形之一，使用**ACB转换**
- 情形4： 有很多A依赖同一个B，而且这些A的变化行为比较一致（会同时一起变化）；
- 情形5： B是不可控模块，而且A对稳定性的要求较高；
- 情形6： A是不可控模块，而且B对稳定性的要求较高；


#### 总结

依赖倒置原则的目的，是通过依赖关系的转移到达隔离变化的作用（即AB问题，减小模块B的变化对模块A的影响）。

依赖倒置的两种核心手段：BA转换和ACB转换。

不要将依赖倒置原则狭义的理解为，面向抽象或面向接口编程；其本质是依赖稳定编程；

好的代码本身就是设计理念的体现。


**软件中的依赖不可消除，只可转移。**

