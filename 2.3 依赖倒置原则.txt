面向对象软件设计的两个核心两步：
**拆解**和**复用**
其中单一职责原则主要讲的是如何拆解，而依赖倒置原则主要讲的是如何复用

**依赖倒置原则（Dependence Inversion Principle，DIP）**：高层次的模块不应该依赖于低层次的模块，它们都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象


### 1. 什么是依赖倒置
先分享一段我自己的亲身经历。

90年代初，我还清晰的记得那会我们村寄信或收信都是要去邮递员家的；当时我父亲在很远的地方打工，我母亲会经常让我把写给父亲的信送到邮递员李四家，一直持续了好几年。但是随着打工潮兴起，村里大量年轻人都跟着去了广东深圳那边，李四也是其中之一。所以有一次我去寄信，李四家人告诉我说李四已经不做邮递员了，现在是村里的王五，于是我需要重新跑到王五家。可是过了一阵子，王五也出门打工去了，邮递员又换成了另外一个。我记得再过了一段时间，村里就没有邮递员了，而是在小卖部那里修了一个邮筒，寄信就扔邮筒里面，镇上的邮递员会每隔几天来村里的邮筒取信，而且会把寄来的信放到小卖部那里自行去取。

这是一个很典型的依赖倒置原则的例子：
寄信这个活动，主要存在两种角色：寄信人和邮递员。
最开始寄信人强依赖于邮递员，寄信需要送到邮递员家。这种模式缺点比较明显，快递员换了很麻烦。到后面增加了邮筒，寄信人和邮递员互不依赖，他们都依赖一个站着不会动的邮筒。

![](C:\Users\A\Desktop\Design-Pattern-main\image\image-20211129161135932.png)

// TODO
我们知道，单一原则主要解决“分”的问题，上面的寄信人和邮递员功能职责边界非常清晰，所以不存在分的问题
而上面邮筒的作用，本质是**隔离变化**：隔离邮递员变化对寄信人的影响。

> **隔离变化**可以认为是依赖倒置原则的本质，**稳定复用**则是依赖倒置原则的目的。

### 2.为什么要依赖倒置
// TODO 2022-9-9 依赖倒置应该适用于所有依赖，只是为了方便讨论，我们可以仅限于我们接触最多的直接依赖。
// TODO 2022-9-29 不要在这里提耦合的种类了，没啥意义。不是一个维度的东西，除了非直接依赖，其他的都是直接依赖，所谓的7种耦合类型，更多的是指业务上的依赖。不能通过设计手段解决。即控制依赖，只要不改变业务关系，两个模块永远都是控制依赖，但我们可以通过依赖倒置缓解这种依赖带来的影响。
依赖的概念其实比较广泛，诸如数据依赖，环境依赖，消息格式依赖等等，依赖倒置中的**依赖**指的是直接依赖，即编译依赖。可以简单地理解为，如果A依赖B，指的是B是A编译通过的必要条件。

> 尽管依赖倒置只讲了如何处理代码依赖带来的问题，但和单一职责原则一样，依赖倒置原则的理念也可以广泛用于各行各业。本章后续如果提及依赖，如果没有特殊说明，都是指代码依赖。

为了方便讨论，我们暂且假定A和B是两个类，我们把A依赖B使用箭头表示如下：
A→B

A→B确实会带来一些问题，比如当B发生**变更**时，A需要跟随**关联修改**，否则编译都会无法通过。为了方便讨论，后续我们讲A依赖于B导致的关联修改问题简称为"**AB问题**"。
> B的变更并不一定会引起A的变化，比如只是修改函数的内部实现逻辑。这里的变更特指会引起关联修改的操作，诸如删除类，修改类名，删除函数，修改函数定义等。

但是代码依赖和关联修改在我们的日常工作中十分常见。任意一个class，都会和他所引入的所有其他类（import显示引用的类和省略了import隐式引用的类）产生依赖关系，并因此导致关联修改。只不过大部分情况，这种依赖都是合理的，产生的关联修改也无可厚非。
但是我们也确实发现，有些场景A→B会带来很严重的困扰，比如。
- 场景1：B**变更**非常频繁；A会被频繁被迫关联修改。
- 场景2：依赖B的面积太大；比如有一百处A1,A2,...,A100均依赖于B，即使B相对比较稳定，偶尔一次**变更**也会导致大量更改和影响。
- 场景3：A和B隶属于不同的模块或团队；没有人希望因为别的团队一个小改动，自己负责的整个模块就要重新发一次版本。（一般公司或多或少都会存在部门墙，尤其是当两个团队属于不同公司时情况会更糟）

除了上面的一些场景，还有一种比较特殊的情况：
- 场景4：A是一个高层模块（公共模块），B是一个低层模块（比如某个业务模块）：当其他模块在使用模块A时，还必须把低层模块B也打包进去，否则会编译不过。
> 场景4中即使A和B属于同一个团队，假使B非常稳定而且永世不会修改，也必须解决A和B之间的代码依赖。
> 关于场景4，并不一定要使用依赖倒置解决，单纯的使用反射或者移动类所在的模块也可以搞定，

因为上述一些场景的存在，在某些时候我们需要解决A→B的问题，而解决这个问题的主要方式便是倒置依赖。

### 3. 如何倒置依赖
如果A→B，只要保持功能最终仍在B中实现（即不使用其他模块代替B，或A自己实现B的功能），这种依赖关系就不可能消除，只能转移。
**依赖不可消除，只可转移。**
> 笔者无法从理论上严谨的证明这一点，但这确实是一个事实。class A中的代码要调用B中的业务逻辑，必然是通过某条代码路径调用过去的，所以这种代码依赖一定存在，只是转移到了很多中间角色中。

我们可以先罗列一下所有可能的依赖转移方式：
1. B→A ：让B反向依赖于A；
2. A→C→B : 增加一个中间层，A间接依赖于B；
3. A→C←B : 增加一个中间层，AB都依赖于C；
4. A←C→B : 增加一个中间层，C依赖于AB，而AB互不依赖；
5. A←C←B : 增加一个中间层，B依赖于C，C依赖于A；

当然，我们可以增加更多的中间层，罗列更多的依赖转换方式。但是无论加多少种，最终都会发现本质上只有两种：
**A→C←B**和**A→C→B**（为了方便后续讨论，我们称之为**BA转换**和**ACB转换**）
而其他的转换方式都是由这两种组合而来：
- B→A：A→B经过BA转换变成A→C←B，将C和A合并或者将它C和A看成一个整体，就是B→A，
- A←C→B：A→B经过ACB转换变成A→C→B，其中A→C进行BA转换变成A←C→B
- A←C←B: A→B经过BA转换变成A←B，其中A←B进行BA转换变成A←C→B

> 如果在类层面讨论依赖转换问题，如果不引入一个接口或类，B→A是无法实现的。当我们讲BA转换，本质上说的其实是A→C←B，只不过往往C和A同属于一个模块或层级，所以表现为B→A；如果把C提升到一个更高的模块，则表现为A→C←B（笔者一般把A→C←B这种表现形式称为“高层解耦”，这是解耦非常常用的一种方式）。


**BA转换**和**ACB转换**是软件设计最重要的两个手段。
> 将A→B变成B→A，刚好是将AB的依赖关系倒置了一下，我猜测这正是依赖倒置原则命名的由来，但无从考证。

从主流的对于依赖倒置原则的理解看，依赖倒置原则应该只包含**BA转换**，这是我个人认为依赖倒置原则定义最失败的地方；反而ACB这种朴实无华，最简单而且最易用的设计手段总是容易被忽视，我从未见过**ACB转换**被一些大师们拎出来单独所讨论，即使它在很多设计模式中都有体现。


#### 3.1 BA转换

**BA转换**对于新手程序员来说会比较难以理解，我们先以最基本的类为例子，看下如何实现BA转换：

1. 依赖一个类的函数
```
public class A {
    public void doSomething(B b) {
        b.hello();
    }
}

public class B {
    public void hello() {

    }
}
```

之前讲过，在类层面BA转换其实是A→C←B，需要新增一个抽象接口C，B去实现C，A依赖C:
```
public interface C {
    void hello();
}

public class A {
    public void doSomething(C c) {
        c.hello();
    }
}

public class B implements C {
    @Override
    public void hello() {

    }
}
```
这样修改之后，A不再直接依赖B。
删除B，修改B的类名都不会影响到A，我们甚至可以创建一个新的B1代替现有的B；这些都不会引起A的关联修改。
```
public class B1 implements C {
    @Override
    public void hello() {

    }
}
```

2. 依赖一个类的创建
```
public class A {
    private B b;

    public void doSomething() {
        if (b == null) {
            b = new B();
        }
        b.hello();
    }
}

public class B {
    public void hello() {

    }
}
```
如按照之前**新增一个抽象接口C，B去实现C，A依赖C**这种方式会发现有问题，最终A还是直接依赖B；
```
public interface C {
    void hello();
}

public class A {
    private C c;

    public void doSomething() {
        if (c == null) {
            c = new B(); // 依然依赖B
        }
        c.hello();
    }
}

public class B implements C {
    @Override
    public void hello() {

    }
}
```
碰到这种情况，一般有如下常见的处理方式：
- 通过构造函数进行初始化
```
public class A {
    private C c;

    public A(C c) {
        this.c = c;
    }

    public void doSomething() {
        this.c.hello();
    }
}
```

- 通过set等方法进行提前设置
```
public class A {
    private C c;

    public void doSomething() {
        this.c.hello();
    }

    public void setC(C c) {
        this.c = c;
    }
}
```

- 通过函数传参
```
public class A {
    private C c;

    public void doSomething(C c) {
        c.hello();
    }
}
```
这些方式本质上都是将对B的创建转移出去，最终变成和方式一类似的情况。
如果我们不想提前设置好C，必须在用的时候自己生成，该怎么办？没有办法，这是BA转换的一个缺点，它**解决不了依赖一个具体对象的创建问题**。有这种需求一般要么使用反射（依赖B的类名），要么使用ACB转换。

细心的读者会发现，BA转换确实可以将AB之间的依赖关系处理的干干净净，他们都只依赖一个没有任何实现的抽象接口C。这确实是一种好的状态，但是B的实例化呢，它终究要存在于某个地方。而这个地方，在《设计模式》一书中，经常会以client的角色出现。
我们可以把client理解为整个系统的启动模块，业务的初始化加载模块等类似角色，它是整个系统最低层模块，它可以肆无忌惮依赖任何其他模块（因为已经是最低层的模块，不会有人再依赖它）。

> client角色的定位注定了它的悲剧，无论设计手段多么高明，解耦多么彻底，抽象接口C终究还是要实例化的，而这种这种抽象的具体实例化，组装，关联，注册等等脏活就全部落在client的肩上（诸如**C c = new B(),a.setC(c)**)类似的语句）。不过比起让内部模块互相耦合纠缠不清来说，将这些依赖集中到一个比较小的范围无疑是更好的方式，而且我们还可以利用java的反射来替换这种直接new的方式，然后将这些类名，方法名放到一个可配置的文本中，以此来实现一些组件的热插拔。
> 大名鼎鼎的spring正是靠着这一手（依赖注入）坐上了java开源件的宝座，这直接让client角色变得格外简单。在早期spring版本，B变更后，往往只需要修改配置文件里面的类名即可，而新版的spring，连配置也省了（参考srping@Autowired用法）。


实际工作中的BA转换，代码要复杂得多，但其本质和上面的例子并无多大差别。大都是声明一个接口C，调用方A只认C定义的接口，被调用方则按照C定义的接口实现即可。不论有多少个A和B，只要遵守C定下来的接口，那么调用方和被调用方就可以随意组合，而且互不依赖，即通过C实现了AB的解耦。
这种解耦不仅可以让B的代码修改不会影响到A，还有一个非常重要的好处便是，我们可以在运行时通过配置**动态替换B**。

如果将上面这段逻辑归纳一下，便是：**定标准**——这就是BA转换的本质，

这个“**标准**”在不同的场景下表现形式不一。

- 如果AB是两个类，**标准**便是一个api函数的定义；可以体现为一个**java interface**，也可以体现为一个**字符串**。
> 笔者之前做过一个项目，需要友商提供一个jar包实现一个功能。我们当时是甲方，我们便直接在代码中写死了类名和函数名，然后通过反射调用友商的功能，所以友商就必须严格按照我们规定的类名，方法名来实现他的功能。这种方式看起来很lower，但它确实可以让我们非常方便的在多个友商间进行选择，我想用友商甲的功能，就加载友商甲的jar包，想用友商乙的功能则加载友商乙的jar包。
> 也许有人为问，为什么不直接定义一个接口让友商去实现呢？这确实也是一种方法，但是这也意味这你必须把这个接口提供给友商，对于当时我司的流程来说，发送源码又或是发送一个接口的详细描述文档给三方都是非常头疼的事情。而且，对方实现了接口又该如何在运行时将他的实例化对象注册进来呢？等等问题，最终这种方式并一定比通过字符串反射生成来得简单。

- 如果AB是两个内部模块或进程，**标准**便是双方交互的内部接口定义；大多体现为一个**excel版或网页版的接口设计文档**。
- 如果AB是两个属于不同团队的服务，**标准**便是一种公共协议或约定；比如**http、sip、JSON**，甚至一个消息中间件或存储介质也能成为他们通信的标准。
> 试想一下，如果没有http这种标准协议，市面上百花齐放的各种浏览器又该如何和成千上万的各种web服务对接？


之前说过，依赖倒置原则可以应用到各行各业。比如下面这个例子：

**乐高积木**

乐高积木有很强的扩展性，我们可以任意挑选不同批次不同包装里面的两个小零件，基本都能拼在一起。其核心便在于乐高定义了一套非常稳定的接口标准：
![](C:\Users\A\Desktop\Design-Pattern-main\image\legaojimu.jpg)

这套标准便是BA转换中的C，只要C不变，AB可任意搭配。

其实这套标准也不难，我们只需要定义好一个”乐高单位“的高度和宽度，凸点和凹点的深度和直径即可；但是试想一下，如果没有这套标准，每套积木都各玩各的，有的长一些，有的短一些，这将对乐高积木的生产和设计带来多么灾难性的后果。

#### 3.2 BA转换的陷阱

至此为止，我们都在讨论BA转换带给我们的幸福生活。但是获得这种幸福的前提条件是C必须非常稳定，否则一旦C出现变更，后果将非常严重。比如上面代码中我们把C定义的函数换了一个名字：
```
public interface C {
    void newHello();
}
```
这时，所有依赖C的A和B都必须修改了，而且这些A和B可能不止一个两个！

也许有人会说，C确实可能会修改，但是不管怎么说，C相对于B肯定会更稳定一些。
真的如此吗？

学过java的对MVC应该都比较清楚，一般这种项目中都会有Service和ServiceImpl类成对的出现，比如：
```
public interface UserService {
    void saveUser(User user);
}

public class UserServiceImpl implements UserService {
    @Override
    public void saveUser(User user) {
        // TODO
    }
}
```
现在让我们发自内心去思考一个问题，到底是Service“依赖”ServiceImpl还是ServiceImpl“依赖”Service?
实际情况是:当需求发生变更时，我们修改的主体一定是ServiceImpl，而Service只是被动去做同步适配而已。更不用说调用Service的Controller类了，它并不会因为它是依赖的一个抽象接口Service而幸免于难。

> Service类存在的必要性与实际项目有关，如果一个Service明显可能存在多个实现，比如将来要将本地调用的Service切换为远程调用的Service等，那么定义Service接口是有意义的。但大多数工程，Service永远都只有一个实现，这种情况下Service接口的定义纯属多余，它只会让你在每次修改ServiceImpl时，还多修改一次Service接口，除了让你多了一些代码产出，毫无意义。
> 
> 还有一种特殊的情况：当项目使用了基于接口的动态代理，Service接口的存在也是必要的。

所以，接口有时候也并不一定比实现类稳定，它有时候甚至会毫无原则的跟随实现类变动。

举个例子，甲公司与乙公司签订合同共同开发一款软件，其中双方的架构师经过讨论，定义了一套清晰的接口文档，于是，双方的开发人员都可以按照接口文档进行独立开发和测试。
最终联调的时候，发现某个接口甲公司实现的不对，并未按照接口文档编写，乙公司开发人员要求甲公司开发人员按照接口文档重新修改实现。但是甲公司架构师经过评估发现，如果此时修改会导致他们工作量很大，所以坚持让乙公司进行修改。
乙公司开发人员小王感到很不满，说接口文档就是这么定的，我们是按照文档做得，是他们弄错了，凭什么我们改；甲公司架构师得知此事后，于是按照甲公司开发人员的实现方式重新去更新了接口文档。

我相信这种事情天天都在世界的某个角落以某种形式发生，而且我也知道这种事情的结局一定是“乙方”修改，因为对方是“**甲方爸爸**”
这种结局并非意料之外。其实换位思考下，如果我们掌握着主导权，肯定也会选择对己方更有利的决策。

所以，不仅是代码中的接口会变，就连白纸黑字的接口文档，国际标准等等在未来的某一天都是极可能发生变化的。而且一旦这个**标准**偏向于其中一方，在**标准**发生变更时，另一方就成为了受害者。这也是很多公司不惜重金也要进入某某协会，某某联盟或某某标准委员会的原因，因为掌控了标准，就掌控了主导权。
> 好在我们常常所做的软件设计，都只是内部A→B问题，无论是A，B还是接口C都由我们自己控制，这样一般不会存在C的偏向问题。但即便如此，因为某些需求的加入，我们也不得不去修改C，然后同时大篇幅的去修改接口的实现者B和调用者A。产生这种情况，有时候是接口定义的不够合理，有些时候却是真的无法避免。

从上面两个例子可以看出，依赖倒置原则的几种常见的理解：面向接口编程或面向抽象编程，其实是不准确的。因为当接口和抽象不稳定时，依赖倒置原则并不能解决任何问题。更准确的说，依赖倒置原则的本质是：面向稳定编程。
只要一个类或模块足够稳定，我们就可以放心的去依赖它，与它是不是标准，是不是抽象，是不是接口没有半点关系。依赖倒置原则之所以建议我们依赖抽象，仅仅是因为抽象大部分情况下比具体稳定而已。

我们常用的String类，就是一个非常具体的实现，但从来不会有人建议我们去使用它的抽象接口CharSequence，甚至可能很多新手都不知道CharSequence的存在。

如果我们依然狭义的去理解依赖倒置原则，那么本章在讲完**BA转换**就应该结束了。但如果将依赖倒置理解为：面向稳定编程，我们会惊奇的发现这条原则的伟大之处，它几乎一人独揽了所有设计模式的半壁江山，而BA转换也仅仅只是其核心手段之一。


#### 3.3 ACB转换

ACB转换相比BA转换，要容易理解很多。
在我个人看来，ACB转换是所有设计手段中最高明的一种。原因无他，简单即美！

```
public class A {
    public void doSomething(B b) {
        b.hello();
    }
}
```
把上面的代码进行ACB转换：
```
public class A {
    public void doSomething(C c) {
        c.hello();
    }
}

public class C {
    private B b;

    public C(B b) {
        this.b = b;
    }

    public void hello() {
        this.b.hello();
    }
}
```

似乎有点多余。但ACB转换确实就是如此，没有任何花里胡哨：本来A直接依赖B，变成A依赖于C，让C帮忙去调用B。如果没有一些具体的例证，甚至让人觉得是不是多此一举。



很久之前笔者曾在XX公司就职，当时对三方件的管理非常严格。其中有一条规则是如果某个三方件有新版本发布，旧版本会在一年后被列入“黑名单”，必须弃用。

当时部门很多团队都使用了apache的commons-lang包，这个三方件提供了大量的工具类，非常好用。但是commons-lang后面进行过一次更新，所有的3.x版本在包路径上加了数字3，比如

org.apache.commons.lang.StringUtils

更名为

org.apache.commons.lang**3**.StringUtils

commons-lang的工具类在我们团队有大量使用，所以，全部门不得不将所有依赖commons-lang的class修改一遍。修改内容也比较简单，就是重新import一下就好，当然，机智的程序员会使用IDE的全局替换功能或者写一个小工具。但是对于一个质量要求很高的产品而言，这种大面积的改动仍然会花费不少工作量，比如担心出现人工上的失误，对所有的改动处进行覆盖测试等等。

唯独我们团队最为轻松，我们所有的业务代码都没有直接使用commons-lang，而是使用我们自己封装的工具类。比如字符串判空，我们自己的工具类写法如下。

```
public class StringUtil {
    ......

    public static boolean isEmpty(String s) {
        return org.apache.commons.lang.StringUtils.isEmpty(s);
    }

    ......
}

```

虽然实际上也调用的是commons-lang的内容，但是三方件更新后，我们只需要更改这一行代码就好。



当然，这种额外封装带来的价值有待商榷，笔者也并非建议我们使用三方件时都去隔离一层。这里仅仅只是一个例子，说明ACB是如何发生作用的：当有成百上千个A依赖同一个B的时候，抽出一个C来隔离B的改动，有时候会给你带来意想不到的效果，况且这种手段是如此的朴实无华。


如果我再举一个例子，大家一定耳熟能详：Java本身。
A代表着java语言开发的所有软件，这是一个非常庞大的群体；
B则是操作系统；
C便是jdk;

从依赖关系看，A依赖C，C依赖B，根据依赖传递原则，A依然依赖B，那么java语言所开发的软件仍然是依赖操作系统的；但是无所谓，依赖就依赖，你改我跟着改就好了。所以当我们更换操作系统，或者操作系统有重大版本更新时，我们也必须更新我们的软件包，但是这种改动微乎其微，只是更换一下相应操作系统版本对应的JDK就好了，亦或是把32位的JDK换成64位。
试想一下，如果没有JDK这层隔离，让业务代码直接依赖了操作系统底层的API，该有多恐怖。各位可以咨询身边C语言相关的同事，就说如果产品经理让他把一个写好的软件从linux切换到windows，会有多大影响。但因为Java语言所做的这一层隔离，可以让上层所有的java语言开发出来的软件完全不用关心底层操作系统的变化。

可以说，正是ACB转换成就了java的跨平台！

> 有很多刚学java的新手认为java是跨平台的，会误以为jdk与操作系统无关。实际上JDK比它上面的任何应用程序软件都要关心操作系统，他需要针对不同的操作系统、不同的版本相应提供不同版本的JDK。

当然，ACB转换也有不足之处，很明显的是ACB转换并不能彻底解决依赖问题，即B更改时，C会受到影响（commons-lang的例子中，我们需要修改我们自己的工具类重新打包；jdk的例子中则是需要更换jdk版本）。但好处也非常明显:
// TODO 每个应该举个例子
- 简单粗暴，而且当A够多的时候，能实实在在的给你省掉很多工作量，只改一个C就好了；
- 能充当防腐层或隔离带的作用：当A是一个非常重要的模块时，我们可以通过增加一个小小的组件C来阻挡B对A的影响；
- 非常友好，没有门槛：它并不会强制要求B或A实现任何接口或标准，AB之间而且互不感知；
- ACB可以解决一些BA模式无法解决的问题，比如B不想实现你定义的接口或者A直接依赖于B的创建时，此时只能使用ACB。


ACB常见的有三种场景:
##### 1. B是一个类或者一个模块
我们使用一个新的类C将B包装起来即可，如果B是一个模块，那么C也会是一个模块。
简单的说，就是通过组合的方式来隐藏B。

有些情况下， 我们还可以将这种组合转换为继承，也可以达到同样的效果:
```
public class A {
    public void doSomething(B b) {
		// hello()方法未来变成了hi()
        b.hello();
    }
}
```


组合式的ACB转换，通过C隔离B对A的影响：
```
public class A {
    public void doSomething(C c) {
        c.hello();
    }
}

public class C {
    private B b;

    public C(B b) {
        this.b = b;
    }

    public void hello() {
        this.b.hi();
    }
}
```

继承式的ACB转换，同样可以通过C隔离B对A的影响：
```
public class A {
    public void doSomething(C c) {
        c.hello();
    }
}

public class C extends B {
    public void hello() {
        this.hi();
    }
}
```

总体来说，前者更灵活，后者更简洁。如果没有特殊情况，我们可以在条件允许的范围内随意选择，即使发现不合适，也可以在不影响A和B的情况下切换成另一种方式。


##### 2. B是一个函数
我们创建一个函数转调即可。

##### 3. B是一段逻辑
比如：
```
    public void method1() {
        // code block 1
        // ...
        // code block 2，same as code block 4
        // ...
    }

    public void method2() {
        // code block 3
        // ...
        // code block 4，same as code block 2
        // ...
    }
```
其中函数method1和method2是两个不同的A, B则是他们相同的那段逻辑(code block 2和code block 4是一模一样，而且他们本身就是同样的业务逻辑——即当他们需要修改的时候肯定会同时修改，注意，B代表的是代码块的业务逻辑，而不是代码块本身)；通过ACB转换，我们可以抽取一个公共方法shareMethod，即ACB转换中的C。这样一旦业务逻辑变化，以前需要修改多处A(method1和method2)，而现在只需要修改C(shareMethod)即可。
```
    public void method1() {
        // code block 1
        // ...
        shareMethod();
    }

    public void method2() {
        // code block 3
        // ...
        shareMethod();
    }

    public void shareMethod() {
        // code block 2
        // ...
    }
```

很多时候，我们抽取公共函数，就是一种ACB转换。

ACB转换，像极了一个大义凛然的英雄（C），为身后想要保护的人（A），扛下了所有的罪过。
如果以后有人说：“搞一个适配器”，“加一个中间层”，其实他这只是要加一个C而已，这并不神秘。

> ACB转换的存在让我对bob大叔《敏捷软件开发》一书中所提到的稳定性度量和稳定依赖原则产生过一些怀疑。无论是根据稳定性度量计算还是根据依赖传递原则，ACB转换中，B肯定都是要比C更为稳定的。既然如此，那么为什么我们原本依赖于更稳定的B，要将它改为去依赖一个相对更不稳定的C呢？最终我发现是我自己对ACB转换产生的误解，ACB转换从一开始就没有想过摆脱对B的依赖，C无论是附属于A模块还是B模块，本质仍然是A→B，他的目的并不是为了不依赖于B，而是更好的依赖B。

#### 3.4 ACB的另用
当存在关系A->B时，我们第一反应是A更为弱势，因为他依赖B。
在BA转换的陷阱一节中，其实有举过例子，实际情况中，谁更强势与谁依赖谁并没有必然关系，主要看谁是甲方。

比如甲方的模块A依赖了乙方模块B的api，虽然此时是A->B，但我们会发现B根本没有说话权。
- B因为自身原因想单方面修改接口，如果影响到A，A大概率会不允许B修改；
- A因为自身原因想当方面修改接口，它会毫无理由的要求B更改为它想要的接口；

所以ACB转换，在A弱势的时候，增加一个C可以隔离B对A的影响。
但当B弱势的时候，C同样也可以隔离A对其各种无理要求的影响。

代码举例则是这样：
```
public class A {
    public void doSomething(B b) {
        b.hello();
    }
}

```

A如果哪说，我不想要你的函数名叫hello，改成hi。
如果B已经被我们内部很多地方使用了，修改函数名影响很大，此时会很难办。但如果我们使用了ACB转换：

```
public class A {
    public void doSomething(C c) {
        c.hello();
    }
}

public class C {
    private B b;

    public C(B b) {
        this.b = b;
    }

    public void hello() {
        this.b.hello();
    }
}
```

此时改一下C，迁就下A就可以了，B并不会受到影响。

```
public class A {
    public void doSomething(C c) {
        c.hi();
    }
}

public class C {
    private B b;

    public C(B b) {
        this.b = b;
    }

    public void hi() {
        this.b.hello();
    }
}
```

所以可以看出，C在充当隔离层时，一般由弱势的一方添加用于保护自身。

#### 3.5 BA转换和ACB转换的比较

我们说依赖倒置的本质是隔离变化，那么我们可以先罗列一下B所有变更的场景，看下BA转换和ACB转换是否真的可以让A不受影响。
我们依然拿最基础的代码举例：
```
public class A {
    public void doSomething(B b) {
        b.hello();
    }
}

public class B {
    public void hello() {

    }
}
```

1. B只是修改其函数内部逻辑，不修改接口。
   无需解决，A本身就不受影响。

2. 使用一种新的实现方式B1代替B（或B修改类名）:
   BA转换可以完美解决， B1实现接口C即可：
```
public interface C {
    void hello();
}

public class A {
    public void doSomething(C c) {
        c.hello();
    }
}

public class B1 implements C {
    @Override
    public void hello() {

    }
}
```
ACB转换也能解决，改动C即可：
```
 public class A {
    public void doSomething(C c) {
        c.hello();
    }
}

public class C {
    private B1 b;

    public C(B1 b) {
        this.b = b;
    }

    public void hello() {
        this.b.hello();
    }
}
```
这两种方式都能很好的保护A。

3. B更改了接口（修改接口名或改变方法的传参、返回值）
BA转换无法做到，A和C都会受影响。
ACB转换可以在A不感知业务变化的情况下做到隔离，比如：
```
 public class A {
    public void doSomething(C c) {
        c.hello();
    }
}

public class C {
    private B b;

    public C(B b) {
        this.b = b;
    }

    public void hello() {
        this.b.hello1(); // 改变方法名
        this.b.hello2("", 1); // 改变传参
    }
}
```
即使修改返回值其实也不会影响到A，因为实际情况，C并不是一个单独的类，可以是多个甚至是一个模块，它会将B的所有信息都隔离开让A不感知。
比如：
```
public class A {
    public void doSomething(B b) {
        B1 b1 = b.hello();
        b1.do();
    }
}

public class B {
    public B1 hello() {

    }
}
```
ACB转换实际上如下：
```
public class A {
    public void doSomething(C c) {
        C1 c1 = c.hello();
        c1.doSomething();
    }
}

public class C {
    private B b;

    public C(B b) {
        this.b = b;
    }

    public C1 hello() {
        return new C1(this.b.hello());
    }
}

public class C1 {
    private B1 b1;

    public C1(B1 b1) {
        this.b1 = b1;
    }

    public void doSomething() {
        this.b1.doSomething();
    }
}
```

如果B的这些变更本身就涉及到A。比如，业务就是需要A多传一些参数，需要A调用B的新api完成一个新的功能等，这种ACB转换也无法解决。
这种改动就好比天要下雨， 娘要嫁人，你自己本身都要变，谁也没法保护你。
> 这种改动，其实可以通过预留多余的接口、使用json，Map之类的集合等方式保持一些可扩展性；如果不是对产品上线后改动特别敏感或者代价特别昂贵的项目，不建议做这种扩展预留。

至此，我们对**BA转换**和**ACB转换**做一些总结：
- 任何两个模块A和B，只要这个改动不涉及到A（A不感知这种业务变化），我们就可以通过合理应用BA转换和ACB转换，达到让B的修改对A不产生影响或影响可控的目的。
- BA转换和ACB转换大部分场景都是为了保护A，即减少或消除B的变化对A的影响（隔离变化）；ACB有少数场景是为了保护B。
- 他们都给A提供了相对稳定的接口，前者提供的接口需要B遵守并实现，后者只是当方面提供给A使用；
- BA转换中C经常作为一个高层模块或A的附属模块，可以让A彻底不依赖B；ACB转换C经常作为A的附属模块，A依然会间接受到B的影响，但影响可控。
- 一旦B发生变化，BA转换可以让A不受任何影响，但是调用侧（client角色）会受到牵连；ACB转换也可以让A不受影响，一般都是C会受到影响，有时也可能是调用侧（使用client角色组装C的场景）。
- BA转换可以在运行时动态将B切换为另一种实现B1，而单纯的使用ACB则无法做到，一般都需要修改代码。
- BA转换中C由强势的一方掌控，ACB转换中C由弱势的一方掌控。


满足以下所有情形，使用**BA转换**：
- 情形1： B是可控模块，即我们可以要求B按照我们定义的接口去实现。
- 情形2： B可能存在多种实现方式，即未来可能会有B1，B2出现；或者A→B违反了稳定依赖原则（A是更高层的模块，不应该依赖于B）
- 情形3： 不涉及对B对象的直接创建；

存在以下情形之一，使用**ACB转换**
- 情形4： 有很多A依赖同一个B，而且这些A的变化行为比较一致（会同时一起变化）；
- 情形5： B是不可控模块，而且A对稳定性的要求较高；
- 情形6： A是不可控模块，而且B对稳定性的要求较高；


#### 总结

依赖倒置原则的目的，是通过依赖关系的转移到达隔离变化的作用（即AB问题，减小模块B的变化对模块A的影响）。

依赖倒置的两种核心手段：BA转换和ACB转换。

不要将依赖倒置原则狭义的理解为，面向抽象或面向接口编程；其本质是依赖稳定编程；

好的代码本身就是设计理念的体现。

