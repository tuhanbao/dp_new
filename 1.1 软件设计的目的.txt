### 1. 为什么需要软件设计
关于为什么做设计，我问过很多同行，其中包含刚从事软件行业的新人，也有很多十余年编码经验的老手。得到的答案无外乎：代码变得更为优美，扩展性更好，更易于维护。

我们可以简单使用一个5Why追问法，来寻找软件设计的最终目的：

  - **为什么要做设计？**
    因为可以让代码扩展性更好，更易维护。
  - **为什么要让代码的扩展性更好，更易维护？**
    因为这样后续修改或增加需求可以更简单。
  - **让修改和增加需求变得简单又是要干嘛？**
    这样我们需要改动的代码就很少。
  - **改动的代码很少对我们有什么好处？**
    代码改动少就可以节省很多工作量。
  - **为什么要节省工作量？**
    可以省时间。
  - **省时间有什么好处？**
    给公司省钱。


如果我们说软件设计的最终目的是为了给公司**省钱**，大概率不会有人提出反对意见，不过这个结论也未免过于偷懒，因为任何一件我们不厌其烦推崇的事情，如果一直追问下去，往往其价值都会归结于“钱”上面。而且简单的将设计的本质归纳于“钱”，也无法区别出软件设计的不同之处，因为在软件的整个生命周期中，我们的很多行为或过程都是为了省钱。诸如：

- 提高人员作战能力（激励，培训）;
- 更好的协同（管理，流程）;
- 节约软件的成本（可测试性，易用性，硬件成本，人力成本）;
- 营销（广告，良好的运营，销售策略）;
- 甚至一个HR通过自身的“忽悠”，用更少的薪酬招聘到一个更优秀的程序员，也可以为公司带来一笔可观的收入;

所以，为了更好的理解软件设计，我们需要把层次拔高一些，先搞清楚软件设计是如何省钱的。

### 2. 软件设计如何省钱

我们假定有两个完全相同的团队A和B（产品经理，项目经理，需求分析师，架构师，测试人员，开发人员，销售、运维和一线人员的能力和人数都完全相同）在完全相同的条件下（相同的时间，地点，硬件设施，软件设施等）开发一款相同的软件（相同的客户，相同的功能需求，时间要求，性能要求，部署要求，所有DFX等等），唯独只有他们负责软件设计的的架构师不一样。那么评判这两个架构师的好坏会变得格外简单，最终哪个团队赚的钱多，我们就可以说哪个软件设计师在这个项目中表现得更为出色，或者说叫**设计更好**。

我们知道：利润 = 销售额 - 成本。
而软件设计肯定是不会改变软件的销售额，因为我们已经假定背景，销售，产品等都完全一样了。
但有人不会太认可这个结论，他们认为客户关系，销售人员的能力，销售策略之类的因素确实与软件设计无关，但是软件产品自身的好坏却与软件设计的好坏强相关，好的架构师设计出来的软件质量可能更好、bug更少、占用的硬件资源也可能更少等等，这些都会导致软件的利润上升，所以上面的假定不成立。
这个质疑确实合理，我们不得不承认，一个好的设计确实会影响到最终的软件产品本身，现实中也确实如此。但是，别忘了我们已经假定了所有DFX需求，质量要求，性能要求是一样的，设计如果越差，就意味着必须投入更多的人力来达到各种DFX和质量需求。只不过现实中最终产品的质量并不是一个完全固定的值，它往往会随着团队能力，资源限制等等因素做一些权衡或妥协。

所以，如果固定好了其他因素，我们可以得出，软件设计影响的一定是**成本**，这应该是一个都能认同的结论。
但关于软件设计是如何影响成本的，可能会存在一些分歧。

### 3. 效率还是工作量？
在假定了所有条件都一样的情况，直接影响成本的因素只有时间。只要缩短时间，整个软件开发过程中的人力成本和非人力成本都会等比降低。而：
**时间 = 工作量 / 开发效率**

那么软件设计影响的要么是开发效率要么是工作量，也可以两者兼具。

关于工作量的定义，我们先看下软件行业对工作量的评估方式：
目前业内工作量的评估方式有以下几种：**专家评估法（WBS）**，**类比类推法**和**参数法（FPA）**。

这些方法本质上都是对历史数据进行加工，然后对当前事务的工作量进行“估算”。
WBS依靠的历史数据是专家的个人历史数据，类比类推依赖于过去同类项目的数据，FPA号称是最有效的软件测量方法，依靠的是整个行业的历史经验数据。

可见，整个行业的工作量评估都是没有专门考虑软件设计因素。不过这个也很好理解，我们不可能在估算工作量的时候去考虑这个项目架构师的能力，只能大致认为他与历史项目中的架构师水平相当，取一个平均值估算再为合理不过；就如我们并不能因为团队中有几个程序员大牛就少评估工作量一样。
我个人并不反对这些评估工作量的方式，只是不得不承认：**软件开发工作量的评估确实忽略了一个好的架构师所带来的正面影响，而且这个影响可能达到一个数量级**。

所以，如果按照业内对工作量的评估方式，对于完全相同质量要求的产品而言最终两个团队的工作量应该是不会存在区别的。也应该如此，我们都已经假定了是完全相同的产品，功能点一样，DFX，质量要求都一样，工作量肯定是固定的，所以**软件设计影响的只能是效率**。

但真的如此吗？

笔者在刚毕业的时候待过一家外包公司，主要给XX公司做一些web管理平台，功能主要是一些配置数据的增删改查，后台也不涉及复杂的算法，仅仅是一些业务相关的校验。
由于项目都类似，所以公司的新项目都是直接拷贝旧项目的代码，并在这基础上进行修改。根据经验，新增一个页面从前到后大概3人天工作量。但是后来某个项目组（暂且叫项目组A）来了一个技术大牛，对代码进行了重构（因为业务主要是数据库的CRUD，进行了一些模板化处理），把这个工作量从3人天缩减到了1人天。假使项目组A不和其他团队进行任何交流，那么项目组A在评估工作量时会变成1人天一个页面，而其他所有团队却还是3人天一个页面，这永远也不会有人觉得奇怪，而且大家都觉得理所应当。

> 软件设计做得再差永远不会背锅：我们会奖励某人提升了多少效率，而会忘记其实效率本该如此。

<br>这个例子给人的第一感觉好像是：**新来的技术大牛把团队的开发效率提了三倍**。但实际上却是我们在评估工作量时由3人天改成了1人天，这明明是工作量减少了三倍。
事实也确实如此：项目组A只是将大量的雷同代码抽象到了更高层，相同的一个页面代码量少了一半以上；尤其在维护阶段，新加一个数据库字段，以前要改十几个文件，而项目组A只需要改一处配置。而且后面实际统计出来也证明了这个结论：当时公司会每个月度统计开发人员的代码产出，项目组A的开发同学月产出代码并不比其他项目组的高。

如果深入思考一下，这个结果是必然的：
两个团队的人员素质相近，业务复杂度也基本一样，使用相同的技术栈，开发语言，开发工具和平台，单位时间写的代码肯定大差不差。

很显然，好的设计并不会**提高效率**，它只是**减少了工作量**。
**好的软件设计并不能让某个程序员顿悟，瞬间提高他的有效代码产出。**

看来，“好的软件设计能提高开发效率”是一个看起来很对但实际却站不住脚的结论。
一个有着糟糕设计的产品，在软件维护周期投入的工作量会尤为明显，仅仅修改一个bug或者新增一个很小的需求都会十分困难。
而有着良好设计的工程，在实现相同功能时需要投入的代码量可能差到一个数量级，这也正是软件设计的魔力所在，我们必须看清这个本质：
**软件设计改变的是工作量，而不是开发效率**。
> 笔者并不想说服所有人都认同这个结论，毕竟站在客户或者产品经理的角度看，最终的软件产品功能一样，他需要三天，你只需要一天，你的效率就是高一些。但作为码农，我们自己心里应该清楚，我们的编码效率并不会因为换了好的架构师就会有所提高，其实只是相同的功能需求或修改所需要的工作量变少了而已。

> 笔者的职业生涯中经常在各种PPT上见过此类论述：我们通过使用新的框架和重新设计（解耦、重构和归一）提升了团队开发效率百分之多少多少，团队的效率从XXX行/人月提升到YYY行/人月，这种论调忽悠了很多领导。

### 4. 软件设计与复杂度

同样一个程序员，假设一个月可以写一千行业务代码，但如果让他去写一个相对更为复杂的业务代码，一个月肯定写不了一千行。
很明显，我们不仅可以通过复用减少代码行数来实现工作量的降低，还可以通过降低复杂度来达成这个目的。

那么，我们说软件设计会影响工作量，那么软件设计会不会影响到复杂度？

首先对于复杂的定义，一般有两种情况：

- 一是繁多。
假设现在有一个一万行的函数，即使这个函数的语法和逻辑都很简单，我们都会觉得这个函数复杂无比；设计很多时候是通过拆解分层解耦等手段，将一些复杂的逻辑分成独立的子逻辑，这种方式可以大大节省后期维护的工作量（在后面章节我们有讨论，这本质上是一种读复用）。
- 二是单纯的难。
比如一个性能要求极高或者专业性很强的算法，即使最终只需要50行代码，那也是好几个人月的工作量，甚至很多人花再多时间也写不出来。我个人认为，**一个软件的难度，都是由业务本身的决定的**；在一个固定的行业，软件设计对软件的困难度毫无影响。

很多时候我们的直观感受会认为好的软件设计不仅会让代码变少，还会感觉代码写起来也会变得简单，其实这仍然是工作量变小的体现。
比如我们说一个模块太复杂了，修改代码完全感觉无从下手，这其实并不是困难，而是繁多。我们改一行代码，需要把很多历史代码读一遍（要知道读代码也是工作量），理清楚里面的逻辑，而这个**逻辑**本身就是业务逻辑，它并不会因为软件设计变得容易一些。糟糕的设计会让代码牵一发而动全身，它并不难，只要你有足够的时间，你可以将他们全部处理好，而且很多时候还需要“特殊处理”，让你引入更糟糕的代码；而好的设计会有更合理的分层和解耦，每次修改会让改动聚集在一块更小的范围，最终会让人觉得简单。

### 5. 软件设计的度量

根据上面的讨论，软件设计影响的就是工作量，它包括读代码和写代码的工作量。所以如果我们要评价设计的好坏，只需要比较软件达到相同要求下在**整个生命周期内**花费的**总人力成本**（或所**需要的总工作量**）即可。而至于我们将设计模式运用的如何高超，代码结构设计的如何优美，通通都只是手段，并不是我们最终需要关心的内容，一切以结果为导向。

可惜的是，我们很难在实际工作中去评判设计的好坏，因为我们缺少对比的参照物。即使我们最终发现开发软件的实际工作量与预估的工作量相差甚远，也很难得出是软件设计很糟糕或很优秀之类结论，因为它很可能是下面的其他原因导致：
- 评估工作量出现失误
- 某个开发人员能力特别突出或特别糟糕
- 前期大量硬编码，后期维护带来大量工作量
- 需求变化

<br>但很难证明是架构师很优秀或很糟糕。
要说明是由于架构师特别优秀导致节约了大量成本，或架构师能力太糟糕导致工作量巨大都过于艰难。我们必须保证在相同条件相同背景而且能力完全相同的团队下换一种设计重新来过，而且还要一直等到软件的生命周期结束才能得以证明架构师存在的价值，而这是一件不可能完成的事情。实际中我们只能进行主观大致判断。

目前度量软件设计的主流工具有：structure101，inFusion；很多大厂内部也有一些专门度量设计的工具，大都是根据一些成熟的设计理论，计算函数的扇入扇出，根据类的引用次数计算依赖值等等，最终计算出一个量化值，用来衡量设计的好坏。

我个人觉得这些工具扫描出的设计缺陷是值得参考的，但是只能作为衡量当前代码与某些设计原则或模式的匹配度，又或者说能从某种角度衡量代码是否“优美”，但这并不能用来衡量软件设计的好和坏。举一个例子，现在有一个**一锤子买卖**的项目，通过工具扫描代码的设计质量很差，耦合十分严重。我觉的这不见得是什么坏事，因为后期不再维护的项目，投入太多在可扩展性反而会成为浪费。这种时候，从结果看这种“差”反而是一种**好的设计**。

> 实际场景下，我们大部分的软件都是设计不足，生命周期也很长，需要长期维护，所以诸如inFusion之类的工具在大部分场景下对软件设计的评判仍然具有参考意义。

<br>笔者非常佩服那些第一个提出想法而且付诸实施的先行者。同样，对于那些尝试量化软件设计好坏的个人或公司我也持有敬佩之心，毕竟一个事情如果不能量化，就代表着很难改进。但是对于量化软件设计这件事情本身，笔者是持悲观态度的，我更觉得美的软件设计偏向于一种艺术，架构师需要在不断的演化中，从理想和现实中寻找一个最佳的平衡点，最终是好是坏只能主观评判。我们尝试通过一些数字来客观评判架构指数，就如“公式相声”的博士夫妻根据观众笑的音量和时长量化“开心指数”一样，听起来很科学，但实际却行不通。
> “公式相声”只是用来说明量化设计这个事情本身非常困难，但对从事这件事的个人和组织，我绝无羞辱之意。但是, 很多外行领导强行量化代码质量的行为和“公式相声”是真的如出一辙。

<br>笔者个人非常反对为了量化而量化的行为，有些领导唯数据论，强迫下面的人必须数据达标，而恰好程序员都有一千种方式来伪造任何数据，尤其是软件设计在当前还没有比较好的量化工具的前提下。
> 很多大师在讲到什么是好的设计的时候，都会说没有最好的设计，而是喜欢用一些“恰到好处”，“刚刚好”，“合适”类似的词语，其实本质上正是对设计无法量化屈服后的无奈之言。而且这种**刚刚好**的说法纯属耍赖，因为包括大师自己在内都没人可以讲清楚什么是**刚刚好**，这些词语只会让软件设计蒙上一层深不可测的哲学面纱，并无其他意义。笔者虽然没有更好的答案，但我知道，设计一定存在好坏之分（两种不同的设计导致的总人力成本一定不同），只是目前我们无法衡量，

### 6. 总结

目前大部分软件设计相关的书籍都在鼓吹软件设计如何好，然后大篇幅的罗列各项原则或模式，但从未从本质上说明：什么是**好**。但是当你与他探讨设计模式好在哪里的时候，他确实会给你一些答案：你运用了这种设计模式，代码就开闭了，解耦了，可扩展性变高了。但当你有一天运用了设计模式，写了一块扩展性很强的代码的时候，又会突然冒出一个“大师”指着你的鼻子说：你这里**过度设计**了。如果我们和“大师”继续深入探讨，会发现最终一定会回到原点：**设计是基于业务本身的**。就好像最终只能凭借个人对于业务的理解来判断一个设计动作的好坏。
虽然我们并不一定要和谁争个你死我活，谁的设计水平更高，但至少做到心中有数。如果有一天别人对你的代码指指点点时，如果他讲不清楚所以然，你可以让他闭嘴，坚持你自己心中的好代码即可。


> 我们虽然无法找到一个绝对理想的圆，但这并不妨碍我们理解什么是圆。