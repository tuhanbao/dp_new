到此为止，我们已经讲完了常见的几大设计原则。
首先是开闭选择喊了一句口号，我们要写好代码！然后是单一职责原则出来给出了解决方案：要写好代码必须让一个软件单元尽量只能包含一个变化因子；接着是依赖倒置原则，最少知道原则和接口隔离原则纷纷为单一职责原则撑腰。除了里氏替换原则，所有的原则似乎都在实现同一个目标：一个软件单元应该只有一个变化因子，也就是我们常说的**隔离变化**。但软件设计并不仅仅只是“隔离不同的变化”，还需要“集中相同的变化”。

如果可以重新定义的话，笔者认为软件设计的第一条准则是：

一个软件单元应该只包含一个变化因子，一个变化因子应该只影响一个软件单元。
> 即解决“合而不同”和“同而不合”的问题！

为了方便描述，我把这条原则暂且称之为隔离复用原则或分治原则。

软件设计是一个分治的过程：先分后治，分是为了治，而治有时需要进一步分，就像金字塔一样自顶向下逐层分解。可以看出，隔离复用原则的前半句说的是“分”，后半句说的是“治”；让“一个软件单元只包含一个变化因子”最终的目的一定是为了让“一个变化因子只影响一个软件单元”，而为了实现“一个变化因子只影响一个软件单元”，我们有时需要进一步的拆解，也就是让“更下层的软件单元只包含一个变化因子”。

从目前的软件设计理论而言，重心基本都在前半句，即**一个软件单元应该只包含一个变化因子**；而对于后半句**一个变化因子应该只影响一个软件单元**只在依赖倒置原则中略有体现。本章笔者将对这一条原则，以及原则在日常代码中的落地手段进行全面的探讨。

### 1. 一个软件单元应该只包含一个变化因子

一个软件单元如果包含的不是一个变化因子，无外乎两种情况：
1. 只包含了一个变化因子的一部分；
2. 包含了多个变化因子；

现实中属于第2种情况的例子非常少见。一个软件单元只包含小半个变化因子一般是因为软件单元拆分的过小，而将软件单元拆分的过小往往需要付出更多的工作量，这是一种反人性的行为；所以我们常常只会见到一个软件单元包含多个变化因子，而一个软件单元只包含部分变化因子的情况则少之又少。
> 在23种设计模式中，只有“中介者模式”出现了这种情况，“中介者模式”刻意将多个经常发生变化的业务逻辑集中到了一起。

出现这种情况时，一般是当事人对“变化因子”的理解出现了一些极端，他可能认为“变化因子”应该要小一些才好。比如，我们要写一个“打人”的功能，如果这个功能逻辑不复杂，代码量也就几行，大部分人会将“打人”看做成一个变化因子写成一个函数；而有些人认为“打人”是由三段不同的逻辑组成，它包含“伸手”、“扇耳光”和“收手”三个步骤，三个步骤都有可能独立变化，所以应该将“变化因子”定义的更小，将“打人”拆分成三个子函数。
```
// 代码片段2.5.1
// 将“打人”拆分成三个独立的变化因子
public void hitYou() {
	// 伸手
	reachOut();
	
	// 打耳光
	slapFace();
	
	// 收手
	stopBack();
	
}

private void reachOut() {
	// some code...
}

private void slapFace() {
	// some code...
}

private void stopBack() {
	// some code...
}


// 将“打人”看成一个整体的变化因子
public void hitYou() {
	// 伸手
	// some code...
	
	// 打耳光
	// some code...
	
	// 收手
	// some code...
	
}
```

这两种思路本身没有对错，但如果实际的业务场景是经常改变打人的整体逻辑，比如某天换成了“伸腿”、“踢一脚”和“收脚”，或者“拿棒子”、“打一下”和“放下棒子”，而不是单独的改变“伸手”、“扇耳光”和“收手”其中一个步骤，那么在代码量本身就很少、逻辑也不复杂、而且这三个步骤也没有其他函数需要共用的情况下，将“打人”这个整体作为一个变化因子可能会更好一些。因为这样修改起来更为方便，而不用每次都修改三个函数。

解决这种问题的办法非常简单，将这些同属于一个变化因子的多个软件单元合起来即可。当然，还有一种更简单的方法，那就是不去理会它，函数分的过小一般不会有太大的影响，只要功能没有问题，我们大可以等到下一次业务发生变化时再来合并它。






### 2. 一个变化因子应该只影响一个软件单元


### 3.总结
